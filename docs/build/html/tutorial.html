
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tutorial &#8212; zfp 0.5.5 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="File Compressor" href="zfpcmd.html" />
    <link rel="prev" title="Fortran Bindings" href="zforp.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="zfpcmd.html" title="File Compressor"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="zforp.html" title="Fortran Bindings"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<span id="id1"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial provides examples that illustrate how to use the zfp
library and compressed arrays, and includes code snippets that show
the order of declarations and function calls needed to use the
compressor.</p>
<p>This tutorial is divided into three parts: the high-level <code class="file docutils literal"><span class="pre">libzfp</span></code>
<a class="reference internal" href="#tut-hl"><span class="std std-ref">library</span></a>; the low-level
<a class="reference internal" href="#tut-ll"><span class="std std-ref">compression codecs</span></a>; and the
<a class="reference internal" href="#tut-arrays"><span class="std std-ref">compressed array classes</span></a> (in that order).  Users
interested only in the compressed arrays, which do not directly expose
anything related to compression other than compression
<a class="reference internal" href="modes.html#mode-fixed-rate"><span class="std std-ref">rate control</span></a>, may safely skip the next two
sections.</p>
<p>All code examples below are for 3D arrays of doubles, but it should be
clear how to modify the function calls for single precision and for 1D,
2D, or 4D arrays.</p>
<div class="section" id="high-level-c-interface">
<span id="tut-hl"></span><h2>High-Level C Interface<a class="headerlink" href="#high-level-c-interface" title="Permalink to this headline">¶</a></h2>
<p>Users concerned only with storing their floating-point data compressed may
use zfp as a black box that maps a possibly non-contiguous floating-point
array to a compressed bit stream.  The intent of <code class="file docutils literal"><span class="pre">libzfp</span></code> is to provide both
a high- and low-level interface to the compressor that can be called from
both C and C++ (and possibly other languages).  <code class="file docutils literal"><span class="pre">libzfp</span></code> supports strided
access, e.g., for compressing vector fields one scalar at a time, or for
compressing arrays of structs.</p>
<p>Consider compressing the 3D C/C++ array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">define</span> <span class="n">an</span> <span class="n">uncompressed</span> <span class="n">array</span>
<span class="n">double</span> <span class="n">a</span><span class="p">[</span><span class="n">nz</span><span class="p">][</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">];</span>
</pre></div>
</div>
<p>where <em>nx</em>, <em>ny</em>, and <em>nz</em> can be any positive dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In multidimensional arrays, the order in which dimensions are specified
is important.  In zfp, the memory layout convention is such that <em>x</em>
varies faster than <em>y</em>, which varies faster than <em>z</em>, and hence <em>x</em> should
map to the innermost (rightmost) array dimension in a C array and to the
leftmost dimension in a Fortran array.  Getting the order of dimensions
right is crucial for good compression and accuracy.  See the discussion of
<a class="reference internal" href="high-level-api.html#indexing"><span class="std std-ref">dimensions and strides</span></a> for further information.</p>
</div>
<p>To invoke the <code class="file docutils literal"><span class="pre">libzfp</span></code> compressor, the dimensions and type must first be
specified in a <a class="reference internal" href="high-level-api.html#c.zfp_field" title="zfp_field"><code class="xref c c-type docutils literal"><span class="pre">zfp_field</span></code></a> parameter object that encapsulates the
type, size, and memory layout of the array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">allocate</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">the</span> <span class="mi">3</span><span class="n">D</span> <span class="n">array</span> <span class="n">a</span><span class="p">[</span><span class="n">nz</span><span class="p">][</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
<span class="n">uint</span> <span class="n">dims</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">zfp_type</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">zfp_type_double</span><span class="p">;</span>
<span class="n">zfp_field</span><span class="o">*</span> <span class="n">field</span> <span class="o">=</span> <span class="n">zfp_field_3d</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">);</span>
</pre></div>
</div>
<p>For single-precision data, use <code class="code docutils literal"><span class="pre">zfp_type_float</span></code>.  As of version 0.5.1,
the high-level API also supports integer arrays (<code class="code docutils literal"><span class="pre">zfp_type_int32</span></code>
and <code class="code docutils literal"><span class="pre">zfp_type_int64</span></code>).  See FAQs <a class="reference internal" href="faq.html#q-integer"><span class="std std-ref">#8</span></a> and
<a class="reference internal" href="faq.html#q-int32"><span class="std std-ref">#9</span></a> regarding integer compression.</p>
<p>Functions similar to <a class="reference internal" href="high-level-api.html#c.zfp_field_3d" title="zfp_field_3d"><code class="xref c c-func docutils literal"><span class="pre">zfp_field_3d()</span></code></a> exist for declaring 1D, 2D, and
4D arrays.  If the dimensionality of the array is unknown at this point, then
a generic <a class="reference internal" href="high-level-api.html#c.zfp_field_alloc" title="zfp_field_alloc"><code class="xref c c-func docutils literal"><span class="pre">zfp_field_alloc()</span></code></a> call can be made to just allocate a
<a class="reference internal" href="high-level-api.html#c.zfp_field" title="zfp_field"><code class="xref c c-type docutils literal"><span class="pre">zfp_field</span></code></a> struct, which can be filled in later using the
<a class="reference internal" href="high-level-api.html#zfp-field-set"><span class="std std-ref">set</span></a> functions.  If the array is non-contiguous, then
<a class="reference internal" href="high-level-api.html#c.zfp_field_set_stride_3d" title="zfp_field_set_stride_3d"><code class="xref c c-func docutils literal"><span class="pre">zfp_field_set_stride_3d()</span></code></a> should be called.</p>
<p>The <a class="reference internal" href="high-level-api.html#c.zfp_field" title="zfp_field"><code class="xref c c-type docutils literal"><span class="pre">zfp_field</span></code></a> parameter object holds information about the
uncompressed array.  To specify the compressed array, a <a class="reference internal" href="high-level-api.html#c.zfp_stream" title="zfp_stream"><code class="xref c c-type docutils literal"><span class="pre">zfp_stream</span></code></a>
object must be allocated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">allocate</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">a</span> <span class="n">compressed</span> <span class="n">stream</span>
<span class="n">zfp_stream</span><span class="o">*</span> <span class="n">zfp</span> <span class="o">=</span> <span class="n">zfp_stream_open</span><span class="p">(</span><span class="n">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>We may now specify the rate, precision, or accuracy (see <a class="reference internal" href="modes.html#modes"><span class="std std-ref">Compression Modes</span></a>
for more details on the meaning of these parameters):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="nb">set</span> <span class="n">compression</span> <span class="n">mode</span> <span class="ow">and</span> <span class="n">parameters</span>
<span class="n">zfp_stream_set_rate</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">zfp_stream_set_precision</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">precision</span><span class="p">);</span>
<span class="n">zfp_stream_set_accuracy</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that only one of these three functions should be called.  The return
value from these functions gives the actual rate, precision, or tolerance,
and may differ slightly from the argument passed due to constraints imposed
by the compressor, e.g., each block must be stored using a whole number of
bits at least as large as the number of bits in the floating-point exponent;
the precision cannot exceed the number of bits in a floating-point value
(i.e., 32 for single and 64 for double precision); and the tolerance must
be a (possibly negative) power of two.</p>
<p>The compression parameters have now been specified, but before compression
can occur a buffer large enough to hold the compressed bit stream must be
allocated.  Another utility function exists for estimating how many bytes
are needed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">allocate</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">compressed</span> <span class="n">data</span>
<span class="n">size_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">zfp_stream_maximum_size</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>
<span class="n">uchar</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">uchar</span><span class="p">[</span><span class="n">bufsize</span><span class="p">];</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="high-level-api.html#c.zfp_stream_maximum_size" title="zfp_stream_maximum_size"><code class="xref c c-func docutils literal"><span class="pre">zfp_stream_maximum_size()</span></code></a> returns the smallest buffer
size necessary to safely compress the data—the <em>actual</em> compressed size
may be smaller.  If the members of <code class="code docutils literal"><span class="pre">zfp</span></code> and <code class="code docutils literal"><span class="pre">field</span></code> are for
whatever reason not initialized correctly, then
<a class="reference internal" href="high-level-api.html#c.zfp_stream_maximum_size" title="zfp_stream_maximum_size"><code class="xref c c-func docutils literal"><span class="pre">zfp_stream_maximum_size()</span></code></a> returns 0.</p>
<p>Before compression can commence, we must associate the allocated buffer
with a bit stream used by the compressor to read and write bits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">associate</span> <span class="n">bit</span> <span class="n">stream</span> <span class="k">with</span> <span class="n">allocated</span> <span class="n">buffer</span>
<span class="n">bitstream</span><span class="o">*</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream_open</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">);</span>
<span class="n">zfp_stream_set_bit_stream</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>Compression can be accelerated via OpenMP multithreading (since zfp
0.5.3) and CUDA (since zfp 0.5.4).  To enable OpenMP
parallel compression, call:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>if (!zfp_stream_set_execution(zfp, zfp_exec_omp)) {
  // OpenMP not available; handle error
}
</pre></div>
</div>
<p>See the section <a class="reference internal" href="execution.html#execution"><span class="std std-ref">Parallel Execution</span></a> for further details on how to configure
zfp and its run-time parameters for parallel compression.</p>
<p>Finally, the array is compressed as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">compress</span> <span class="n">entire</span> <span class="n">array</span>
<span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">zfp_compress</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>
</pre></div>
</div>
<p>If the stream was rewound before calling <a class="reference internal" href="high-level-api.html#c.zfp_compress" title="zfp_compress"><code class="xref c c-func docutils literal"><span class="pre">zfp_compress()</span></code></a>,
the return value is the actual number of bytes of compressed storage,
and as already mentioned, <em>size</em> ≤ <em>bufsize</em>.  If <em>size</em> = 0, then the
compressor failed.  Since zfp 0.5.0, the compressor does not rewind the
bit stream before compressing, which allows multiple fields to be compressed
one after the other.  The return value from <a class="reference internal" href="high-level-api.html#c.zfp_compress" title="zfp_compress"><code class="xref c c-func docutils literal"><span class="pre">zfp_compress()</span></code></a> is always
the total number of bytes of compressed storage so far relative to the memory
location pointed to by <em>buffer</em>.</p>
<p>To decompress the data, the field and compression parameters must be
initialized with the same values as used for compression, either via
the same sequence of function calls as above or by recording these
fields and setting them directly.  Metadata such as array dimensions and
compression parameters are by default not stored in the compressed stream.
It is up to the caller to store this information, either separate from
the compressed data, or via the <a class="reference internal" href="high-level-api.html#c.zfp_write_header" title="zfp_write_header"><code class="xref c c-func docutils literal"><span class="pre">zfp_write_header()</span></code></a> and
<a class="reference internal" href="high-level-api.html#c.zfp_read_header" title="zfp_read_header"><code class="xref c c-func docutils literal"><span class="pre">zfp_read_header()</span></code></a> calls, which should precede the corresponding
<a class="reference internal" href="high-level-api.html#c.zfp_compress" title="zfp_compress"><code class="xref c c-func docutils literal"><span class="pre">zfp_compress()</span></code></a> and <a class="reference internal" href="high-level-api.html#c.zfp_decompress" title="zfp_decompress"><code class="xref c c-func docutils literal"><span class="pre">zfp_decompress()</span></code></a> calls, respectively.
These calls allow the user to specify what information to store in the header,
including a ‘magic’ format identifier, the field type and dimensions, and the
compression parameters (see the <a class="reference internal" href="high-level-api.html#header-macros"><span class="std std-ref">ZFP_HEADER</span></a> macros).</p>
<p>In addition to this initialization, the bit stream has to be rewound to
the beginning (before reading the header and decompressing the data):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">rewind</span> <span class="n">compressed</span> <span class="n">stream</span> <span class="ow">and</span> <span class="n">decompress</span> <span class="n">array</span>
<span class="n">zfp_stream_rewind</span><span class="p">(</span><span class="n">zfp</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">zfp_decompress</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>
</pre></div>
</div>
<p>The return value is zero if the decompressor failed.</p>
<div class="section" id="simple-example">
<h3>Simple Example<a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h3>
<p>Tying it all together, the code example below (see also the
<a class="reference internal" href="examples.html#ex-simple"><span class="std std-ref">simple</span></a> program) shows how to compress a 3D array
<code class="code docutils literal"><span class="pre">double</span> <span class="pre">array[nz][ny][nx]</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="nb">input</span><span class="p">:</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nx</span><span class="p">,</span> <span class="nb">int</span> <span class="n">ny</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nz</span><span class="p">,</span> <span class="n">double</span> <span class="n">tolerance</span><span class="p">)</span>

<span class="o">//</span> <span class="n">initialize</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">the</span> <span class="mi">3</span><span class="n">D</span> <span class="n">array</span> <span class="n">a</span><span class="p">[</span><span class="n">nz</span><span class="p">][</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
<span class="n">zfp_type</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">zfp_type_double</span><span class="p">;</span>                          <span class="o">//</span> <span class="n">array</span> <span class="n">scalar</span> <span class="nb">type</span>
<span class="n">zfp_field</span><span class="o">*</span> <span class="n">field</span> <span class="o">=</span> <span class="n">zfp_field_3d</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">);</span> <span class="o">//</span> <span class="n">array</span> <span class="n">metadata</span>

<span class="o">//</span> <span class="n">initialize</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">a</span> <span class="n">compressed</span> <span class="n">stream</span>
<span class="n">zfp_stream</span><span class="o">*</span> <span class="n">zfp</span> <span class="o">=</span> <span class="n">zfp_stream_open</span><span class="p">(</span><span class="n">NULL</span><span class="p">);</span>                  <span class="o">//</span> <span class="n">compressed</span> <span class="n">stream</span> <span class="ow">and</span> <span class="n">parameters</span>
<span class="n">zfp_stream_set_accuracy</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">);</span>                  <span class="o">//</span> <span class="nb">set</span> <span class="n">tolerance</span> <span class="k">for</span> <span class="n">fixed</span><span class="o">-</span><span class="n">accuracy</span> <span class="n">mode</span>
<span class="o">//</span>  <span class="n">zfp_stream_set_precision</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">precision</span><span class="p">);</span>             <span class="o">//</span> <span class="n">alternative</span><span class="p">:</span> <span class="n">fixed</span><span class="o">-</span><span class="n">precision</span> <span class="n">mode</span>
<span class="o">//</span>  <span class="n">zfp_stream_set_rate</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>           <span class="o">//</span> <span class="n">alternative</span><span class="p">:</span> <span class="n">fixed</span><span class="o">-</span><span class="n">rate</span> <span class="n">mode</span>

<span class="o">//</span> <span class="n">allocate</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">compressed</span> <span class="n">data</span>
<span class="n">size_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">zfp_stream_maximum_size</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>     <span class="o">//</span> <span class="n">capacity</span> <span class="n">of</span> <span class="n">compressed</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">conservative</span><span class="p">)</span>
<span class="n">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">);</span>                           <span class="o">//</span> <span class="n">storage</span> <span class="k">for</span> <span class="n">compressed</span> <span class="n">stream</span>

<span class="o">//</span> <span class="n">associate</span> <span class="n">bit</span> <span class="n">stream</span> <span class="k">with</span> <span class="n">allocated</span> <span class="n">buffer</span>
<span class="n">bitstream</span><span class="o">*</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">stream_open</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">);</span>         <span class="o">//</span> <span class="n">bit</span> <span class="n">stream</span> <span class="n">to</span> <span class="n">compress</span> <span class="n">to</span>
<span class="n">zfp_stream_set_bit_stream</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>                   <span class="o">//</span> <span class="n">associate</span> <span class="k">with</span> <span class="n">compressed</span> <span class="n">stream</span>
<span class="n">zfp_stream_rewind</span><span class="p">(</span><span class="n">zfp</span><span class="p">);</span>                                   <span class="o">//</span> <span class="n">rewind</span> <span class="n">stream</span> <span class="n">to</span> <span class="n">beginning</span>

<span class="o">//</span> <span class="n">compress</span> <span class="n">array</span>
<span class="n">size_t</span> <span class="n">zfpsize</span> <span class="o">=</span> <span class="n">zfp_compress</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>                <span class="o">//</span> <span class="k">return</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">byte</span> <span class="n">size</span> <span class="n">of</span> <span class="n">compressed</span> <span class="n">stream</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="low-level-c-interface">
<span id="tut-ll"></span><h2>Low-Level C Interface<a class="headerlink" href="#low-level-c-interface" title="Permalink to this headline">¶</a></h2>
<p>For applications that wish to compress or decompress portions of an array
on demand, a low-level interface is available.  Since this API is useful
primarily for supporting random access, the user also needs to manipulate
the <a class="reference internal" href="bit-stream.html#bs-api"><span class="std std-ref">bit stream</span></a>, e.g., to position the bit pointer to where
data is to be read or written.  Please be advised that the bit stream
functions have been optimized for speed and do not check for buffer
overruns or other types of programmer error.</p>
<p>Like the high-level API, the low-level API also makes use of the
<a class="reference internal" href="high-level-api.html#c.zfp_stream" title="zfp_stream"><code class="xref c c-type docutils literal"><span class="pre">zfp_stream</span></code></a> parameter object (see previous section) to specify
compression parameters and storage, but does not encapsulate array
metadata in a <a class="reference internal" href="high-level-api.html#c.zfp_field" title="zfp_field"><code class="xref c c-type docutils literal"><span class="pre">zfp_field</span></code></a> object.  Functions exist for encoding
and decoding complete or partial blocks, with or without strided access.
In non-strided mode, the uncompressed block to be encoded or decoded is
assumed to be stored contiguously.  For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">compress</span> <span class="n">a</span> <span class="n">single</span> <span class="n">contiguous</span> <span class="n">block</span>
<span class="n">double</span> <span class="n">block</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">/*</span> <span class="n">some</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">values</span> <span class="o">*/</span> <span class="p">};</span>
<span class="n">uint</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">zfp_encode_block_double_3</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</pre></div>
</div>
<p>The return value is the number of bits of compressed storage for the block.
For fixed-rate streams, if random write access is desired, then the stream
should also be flushed after each block is encoded:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">flush</span> <span class="nb">any</span> <span class="n">buffered</span> <span class="n">bits</span>
<span class="n">zfp_stream_flush</span><span class="p">(</span><span class="n">zfp</span><span class="p">);</span>
</pre></div>
</div>
<p>This flushing should be done only after the last block has been compressed in
fixed-precision and fixed-accuracy mode, or when random access is not needed
in fixed-rate mode.</p>
<p>The block above could also have been compressed as follows using strides:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">compress</span> <span class="n">a</span> <span class="n">single</span> <span class="n">contiguous</span> <span class="n">block</span> <span class="n">using</span> <span class="n">strides</span>
<span class="n">double</span> <span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">/*</span> <span class="n">some</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">values</span> <span class="o">*/</span> <span class="p">};</span>
<span class="nb">int</span> <span class="n">sx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="o">//</span> <span class="n">x</span> <span class="n">stride</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="nb">int</span> <span class="n">sy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="o">//</span> <span class="n">y</span> <span class="n">stride</span> <span class="o">=</span>  <span class="mi">4</span>
<span class="nb">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="o">//</span> <span class="n">z</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">uint</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">zfp_encode_block_strided_double_3</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
</pre></div>
</div>
<p>The strides are measured in number of scalars, not in bytes.</p>
<p>For partial blocks, e.g., near the boundaries of arrays whose dimensions
are not multiples of four, there are corresponding functions that accept
parameters <em>nx</em>, <em>ny</em>, and <em>nz</em> to specify the actual block dimensions,
with 1 ≤ <em>nx</em>, <em>ny</em>, <em>nz</em> ≤ 4.  Corresponding functions exist for
decompression.  Such partial blocks typically do not compress as well as
full blocks and should be avoided if possible.</p>
<p>To position a bit stream for reading (decompression), use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">position</span> <span class="n">the</span> <span class="n">stream</span> <span class="n">at</span> <span class="n">given</span> <span class="n">bit</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">reading</span>
<span class="n">stream_rseek</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>where the offset is measured in number of bits from the beginning of the
stream.  For writing (compression), a corresponding call exists:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">position</span> <span class="n">the</span> <span class="n">stream</span> <span class="n">at</span> <span class="n">given</span> <span class="n">bit</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">writing</span>
<span class="n">stream_wseek</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that it is possible to decompress fewer bits than are stored with a
compressed block to quickly obtain an approximation.  This is done by
setting <code class="code docutils literal"><span class="pre">zfp-&gt;maxbits</span></code> to fewer bits than used during compression.
For example, to decompress only the first 256 bits of each block:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">modify</span> <span class="n">decompression</span> <span class="n">parameters</span> <span class="n">to</span> <span class="n">decode</span> <span class="mi">256</span> <span class="n">bits</span> <span class="n">per</span> <span class="n">block</span>
<span class="n">uint</span> <span class="n">maxbits</span><span class="p">;</span>
<span class="n">uint</span> <span class="n">maxprec</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">minexp</span><span class="p">;</span>
<span class="n">zfp_stream_params</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxbits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxprec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">minexp</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">maxbits</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">);</span>
<span class="n">zfp_stream_set_params</span><span class="p">(</span><span class="n">zfp</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">maxprec</span><span class="p">,</span> <span class="n">minexp</span><span class="p">);</span>
</pre></div>
</div>
<p>This feature may be combined with progressive decompression, as discussed
further in FAQ <a class="reference internal" href="faq.html#q-progressive"><span class="std std-ref">#13</span></a>.</p>
</div>
<div class="section" id="compressed-c-arrays">
<span id="tut-arrays"></span><h2>Compressed C++ Arrays<a class="headerlink" href="#compressed-c-arrays" title="Permalink to this headline">¶</a></h2>
<p>The zfp compressed array API, which currently supports 1D, 2D, and 3D
(but not 4D) arrays, has been designed to facilitate integration with existing
applications.  After initial array declaration, a zfp array can often
be used in place of a regular C/C++ array or STL vector, e.g., using flat
indexing via <code class="code docutils literal"><span class="pre">a[index]</span></code>, nested indexing <code class="code docutils literal"><span class="pre">a[k][j][i]</span></code> (via
<a class="reference internal" href="arrays.html#nested-view"><span class="std std-ref">nested views</span></a>), or using multidimensional indexing via
<code class="code docutils literal"><span class="pre">a(i)</span></code>, <code class="code docutils literal"><span class="pre">a(i,</span> <span class="pre">j)</span></code>, or <code class="code docutils literal"><span class="pre">a(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code>.  There are,
however, some important differences.  For instance, applications that
rely on addresses or references to array elements may have to be
modified to use special proxy classes that implement pointers and
references; see <a class="reference internal" href="limitations.html#limitations"><span class="std std-ref">Limitations</span></a>.</p>
<p>zfp’s compressed arrays do not support special floating-point values like
infinities and NaNs, although subnormal numbers are handled correctly.
Similarly, because the compressor assumes that the array values vary smoothly,
using finite but large values like <code class="xref c c-macro docutils literal"><span class="pre">HUGE_VAL</span></code> in place of
infinities is not advised, as this will introduce large errors in smaller
values within the same block.  Future extensions will provide support for
a bit mask to mark the presence of non-values.</p>
<p>The zfp C++ classes are implemented entirely as header files and make
extensive use of C++ templates to reduce code redundancy.  These classes
are wrapped in the <code class="xref cpp cpp-any docutils literal"><span class="pre">zfp</span></code> namespace.</p>
<p>Currently, there are six array classes for 1D, 2D, and 3D arrays, each of
which can represent single- or double-precision values.  Although these
arrays store values in a form different from conventional single- and
double-precision floating point, the user interacts with the arrays via
floats and doubles.</p>
<p>The description below is for 3D arrays of doubles—the necessary changes
for other array types should be obvious.  To declare and zero initialize
an array, use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">declare</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span> <span class="n">array</span> <span class="n">of</span> <span class="n">compressed</span> <span class="n">doubles</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
</pre></div>
</div>
<p>This declaration is conceptually equivalent to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">a</span><span class="p">[</span><span class="n">nz</span><span class="p">][</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">};</span>
</pre></div>
</div>
<p>or using STL vectors</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</div>
<p>but with the user specifying the amount of storage used via the <em>rate</em>
parameter.  (A predefined type <code class="xref cpp cpp-type docutils literal"><span class="pre">array3d</span></code> also exists, while
the suffix ‘f’ is used for floats.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In multidimensional arrays, the order in which dimensions are specified
is important.  In zfp, the memory layout convention is such that <em>x</em>
varies faster than <em>y</em>, which varies faster than <em>z</em>, and hence <em>x</em> should
map to the innermost (rightmost) array dimension in a C array and to the
leftmost dimension in a Fortran array.  Getting the order of dimensions
right is crucial for good compression and accuracy.  See the discussion of
<a class="reference internal" href="high-level-api.html#indexing"><span class="std std-ref">dimensions and strides</span></a> for further information.</p>
</div>
<p>Note that the array dimensions can be arbitrary and need not be multiples
of four (see above for a discussion of incomplete blocks).  The <em>rate</em>
argument specifies how many bits per value (amortized) to store in the
compressed representation.  By default, the block size is restricted to a
multiple of 64 bits, and therefore the rate argument can be specified in
increments of 64 / 4<sup>d</sup> bits in <em>d</em> dimensions, i.e.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
<span class="mi">2</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">4</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
<span class="mi">3</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
</pre></div>
</div>
<p>For finer granularity, the <a class="reference internal" href="installation.html#c.BIT_STREAM_WORD_TYPE" title="BIT_STREAM_WORD_TYPE"><code class="xref c c-macro docutils literal"><span class="pre">BIT_STREAM_WORD_TYPE</span></code></a> macro needs to
be set to a type narrower than 64 bits during compilation of <code class="file docutils literal"><span class="pre">libzfp</span></code>,
e.g., if set to <code class="xref c c-type docutils literal"><span class="pre">uint8</span></code> the rate granularity becomes 8 / 4<sup>d</sup>
bits in <em>d</em> dimensions, or</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">2</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
<span class="mi">2</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
<span class="mi">3</span><span class="n">D</span> <span class="n">arrays</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="n">bit</span> <span class="n">granularity</span>
</pre></div>
</div>
<p>Note that finer granularity usually implies slightly lower performance.
Also note that because the arrays are stored compressed, their effective
precision is likely to be higher than the user-specified rate.</p>
<p>The array can also optionally be initialized from an existing contiguous
floating-point array stored at <em>pointer</em> with an <em>x</em> stride of 1, <em>y</em>
stride of <em>nx</em>, and <em>z</em> stride of <em>nx</em> × <em>ny</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">declare</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="mi">3</span><span class="n">D</span> <span class="n">array</span> <span class="n">of</span> <span class="n">doubles</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">pointer</span><span class="p">,</span> <span class="n">cache_size</span><span class="p">);</span>
</pre></div>
</div>
<p>The optional <em>cache_size</em> argument specifies the minimum number of bytes
to allocate for the cache of uncompressed blocks (see <a class="reference internal" href="#tut-caching"><span class="std std-ref">Caching</span></a>
below for more details).</p>
<p>As of zfp 0.5.3, entire arrays may be copied via the copy constructor or
assignment operator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">declare</span> <span class="n">array</span> <span class="n">b</span> <span class="n">to</span> <span class="n">be</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">array</span> <span class="n">a</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">c</span><span class="p">;</span> <span class="o">//</span> <span class="n">declare</span> <span class="n">empty</span> <span class="n">array</span> <span class="n">c</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">a</span> <span class="n">to</span> <span class="n">c</span>
</pre></div>
</div>
<p>Copies are deep and have value (not reference) semantics.  In the above
example, separate storage for <em>b</em> and <em>c</em> is allocated, and subsequent
modifications to <em>b</em> and <em>c</em> will not modify <em>a</em>.</p>
<p>If not already initialized, a function <a class="reference internal" href="arrays.html#_CPPv2N3zfp5array3setEPK6Scalar" title="zfp::array::set"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set()</span></code></a> can be used
to copy uncompressed data to the compressed array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">double</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span> <span class="o">//</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">uncompressed</span><span class="p">,</span> <span class="n">initialized</span> <span class="n">data</span>
<span class="n">a</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span> <span class="o">//</span> <span class="n">initialize</span> <span class="n">compressed</span> <span class="n">array</span> <span class="k">with</span> <span class="n">floating</span><span class="o">-</span><span class="n">point</span> <span class="n">data</span>
</pre></div>
</div>
<p>Similarly, an <a class="reference internal" href="arrays.html#_CPPv2NK3zfp5array3getEP6Scalar" title="zfp::array::get"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::get()</span></code></a> function exists for retrieving
uncompressed data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span> <span class="o">//</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">where</span> <span class="n">to</span> <span class="n">write</span> <span class="n">uncompressed</span> <span class="n">data</span>
<span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span> <span class="o">//</span> <span class="n">decompress</span> <span class="ow">and</span> <span class="n">store</span> <span class="n">the</span> <span class="n">array</span> <span class="n">at</span> <span class="n">pointer</span>
</pre></div>
</div>
<p>The compressed representation of an array can also be queried or initialized
directly without having to convert to/from its floating-point representation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">size_t</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="n">compressed_size</span><span class="p">();</span> <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">of</span> <span class="n">compressed</span> <span class="n">storage</span>
<span class="n">uchar</span><span class="o">*</span> <span class="n">compressed_data</span><span class="p">();</span> <span class="o">//</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">compressed</span> <span class="n">data</span>
</pre></div>
</div>
<p>The array can through this pointer be initialized from offline compressed
storage, but only after its dimensions and rate have been specified (see
above).  For this to work properly, the cache must first be emptied via a
<a class="reference internal" href="arrays.html#_CPPv2NK3zfp5array11clear_cacheEv" title="zfp::array::clear_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::clear_cache()</span></code></a> call (see below).</p>
<p>Through operator overloading, the array can be accessed in one of two ways.
For read accesses, use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="o">//</span> <span class="n">fetch</span> <span class="n">value</span> <span class="k">with</span> <span class="n">given</span> <span class="n">flat</span> <span class="n">array</span> <span class="n">index</span>
<span class="n">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="o">//</span> <span class="n">fetch</span> <span class="n">value</span> <span class="k">with</span> <span class="mi">3</span><span class="n">D</span> <span class="n">index</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>These access the same value if and only if
<code class="code docutils literal"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">nx</span> <span class="pre">*</span> <span class="pre">(j</span> <span class="pre">+</span> <span class="pre">ny</span> <span class="pre">*</span> <span class="pre">k)</span></code>.
Note that 0 ≤ <em>i</em> &lt; <em>nx</em>, 0 ≤ <em>j</em> &lt; <em>ny</em>, and 0 ≤ <em>k</em> &lt; <em>nz</em>,
and <em>i</em> varies faster than <em>j</em>, which varies faster than <em>k</em>.</p>
<p>zfp 0.5.4 adds views to arrays, which among other things can
be used to perform nested indexing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="p">::</span><span class="n">nested_view</span> <span class="n">v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="n">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<p>A view is a shallow copy of an array or a subset of an array.</p>
<p>Array values may be written and updated using the usual set of C++ assignment
and compound assignment operators.  For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="o">//</span> <span class="nb">set</span> <span class="n">value</span> <span class="n">at</span> <span class="n">flat</span> <span class="n">array</span> <span class="n">index</span>
<span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="o">//</span> <span class="n">increment</span> <span class="n">value</span> <span class="k">with</span> <span class="mi">3</span><span class="n">D</span> <span class="n">index</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>Whereas one might expect these operators to return a (non-const) reference
to an array element, this would allow seating a reference to a value that
currently is cached but is transient, which could be unsafe.  Moreover,
this would preclude detecting when an array element is modified.  Therefore,
the return type of both operators <code class="code docutils literal"><span class="pre">[]</span></code> and <code class="code docutils literal"><span class="pre">()</span></code> is a proxy
reference class, similar to <code class="code docutils literal"><span class="pre">std::vector&lt;bool&gt;::reference</span></code> from the
STL library.  Because read accesses to a mutable object cannot call the
const-qualified accessor, a proxy reference may be returned even for read
calls.  For example, in</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</pre></div>
</div>
<p>the array <code class="code docutils literal"><span class="pre">a</span></code> clearly must be mutable to allow assignment to
<code class="code docutils literal"><span class="pre">a[i]</span></code>, and therefore the read access <code class="code docutils literal"><span class="pre">a[i</span> <span class="pre">+</span> <span class="pre">1]</span></code> returns type
<code class="xref cpp cpp-class docutils literal"><span class="pre">array::reference</span></code>.  The value associated with the read access
is obtained via an implicit conversion.</p>
<p>Array dimensions <em>nx</em>, <em>ny</em>, and <em>nz</em> can be queried using these functions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">size_t</span> <span class="n">size</span><span class="p">();</span> <span class="o">//</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span>
<span class="n">uint</span> <span class="n">size_x</span><span class="p">();</span> <span class="o">//</span> <span class="n">nx</span>
<span class="n">uint</span> <span class="n">size_y</span><span class="p">();</span> <span class="o">//</span> <span class="n">ny</span>
<span class="n">uint</span> <span class="n">size_z</span><span class="p">();</span> <span class="o">//</span> <span class="n">nz</span>
</pre></div>
</div>
<p>The array dimensions can also be changed dynamically, e.g., if not known
at time of construction, using</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">resize</span><span class="p">(</span><span class="n">uint</span> <span class="n">nx</span><span class="p">,</span> <span class="n">uint</span> <span class="n">ny</span><span class="p">,</span> <span class="n">uint</span> <span class="n">nz</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">clear</span> <span class="o">=</span> <span class="n">true</span><span class="p">);</span>
</pre></div>
</div>
<p>When <em>clear</em> = true, the array is explicitly zeroed.  In either case, all
previous contents of the array are lost.  If <em>nx</em> = <em>ny</em> = <em>nz</em> = 0, all
storage is freed.</p>
<p>Finally, the rate supported by the array may be queried via</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">rate</span><span class="p">();</span> <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">compressed</span> <span class="n">bits</span> <span class="n">per</span> <span class="n">value</span>
</pre></div>
</div>
<p>and changed using</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">set_rate</span><span class="p">(</span><span class="n">rate</span><span class="p">);</span> <span class="o">//</span> <span class="n">change</span> <span class="n">rate</span>
</pre></div>
</div>
<p>This also destroys prior contents.</p>
<p>As of zfp 0.5.2, iterators and proxy objects for pointers and references are
supported.  Note that the decompressed value of an array element exists only
intermittently, when the decompressed value is cached.  It would not be safe
to return a <code class="code docutils literal"><span class="pre">double&amp;</span></code> reference or <code class="code docutils literal"><span class="pre">double*</span></code> pointer to the cached
but transient value since it may be evicted from the cache at any point, thus
invalidating the reference or pointer.  Instead, zfp provides proxy objects
for references and pointers that guarantee persistent access by referencing
elements by array object and index.  These classes perform decompression on
demand, much like how Boolean vector references are implemented in the STL.</p>
<p>Iterators for 1D arrays support random access, while 2D and 3D array iterators
are merely forward (sequential) iterators.  All iterators ensure that array
values are visited one block at a time, and are the preferred way of looping
over array elements.  Such block-by-block access is especially useful when
performing write accesses since then complete blocks are updated one at a
time, thus reducing the likelihood of a partially updated block being evicted
from the cache and compressed, perhaps with some values in the block being
uninitialized.  Here is an example of initializing a 3D array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="p">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">i</span><span class="p">();</span>
  <span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">j</span><span class="p">();</span>
  <span class="nb">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">k</span><span class="p">();</span>
  <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pointers to array elements are available via a special pointer class.  Such
pointers may be a useful way of passing (flattened) zfp arrays to functions
that expect uncompressed arrays, e.g., by using the pointer type as template
argument.  For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">double_ptr</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="nb">sum</span><span class="p">(</span><span class="n">double_ptr</span> <span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then the following are equivalent:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">STL</span> <span class="n">vector</span> <span class="n">elements</span> <span class="p">(</span><span class="n">double_ptr</span> <span class="o">==</span> <span class="n">double</span><span class="o">*</span><span class="p">)</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="n">double</span> <span class="n">vecsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">);</span>

<span class="o">//</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">zfp</span> <span class="n">array</span> <span class="n">elements</span> <span class="p">(</span><span class="n">double_ptr</span> <span class="o">==</span> <span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="p">::</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
<span class="n">double</span> <span class="n">zfpsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">);</span>
</pre></div>
</div>
<p>As another example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">zfp</span><span class="p">::</span><span class="n">array1d</span><span class="p">::</span><span class="n">pointer</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</pre></div>
</div>
<p>initializes a 1D array to all-zeros.  Pointers visit arrays in standard
row-major order, i.e.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nx</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="o">==</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">nx</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">k</span><span class="p">)]</span>
</pre></div>
</div>
<p>where <code class="code docutils literal"><span class="pre">&amp;a(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code> and <code class="code docutils literal"><span class="pre">&amp;a[0]</span></code> are both of type
<code class="xref cpp cpp-class docutils literal"><span class="pre">array3d::pointer</span></code>.  Thus, iterators and pointers do not
visit arrays in the same order, except for the special case of 1D arrays.
Unlike iterators, pointers support random access for arrays of all
dimensions and behave very much like <code class="code docutils literal"><span class="pre">float*</span></code> and <code class="code docutils literal"><span class="pre">double*</span></code>
built-in pointers.</p>
<p>Proxy objects for array element references have been supported since the
first release of zfp, and may for instance be used in place of
<code class="code docutils literal"><span class="pre">double&amp;</span></code>.  Iterators and pointers are implemented in terms of
references.</p>
<p>The following table shows the equivalent zfp type to standard types when
working with 1D arrays:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span><span class="o">&amp;</span>                         <span class="n">zfp</span><span class="p">::</span><span class="n">array1d</span><span class="p">::</span><span class="n">reference</span>
<span class="n">double</span><span class="o">*</span>                         <span class="n">zfp</span><span class="p">::</span><span class="n">array1d</span><span class="p">::</span><span class="n">pointer</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">iterator</span>   <span class="n">zfp</span><span class="p">::</span><span class="n">array1d</span><span class="p">::</span><span class="n">iterator</span>
</pre></div>
</div>
<div class="section" id="caching">
<span id="tut-caching"></span><h3>Caching<a class="headerlink" href="#caching" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, the array class maintains a software write-back cache
of at least one uncompressed block.  When a block in this cache is evicted
(e.g., due to a conflict), it is compressed back to permanent storage only
if it was modified while stored in the cache.</p>
<p>The size cache to use is specified by the user and is an important
parameter that needs careful consideration in order to balance the extra
memory usage, performance, and accuracy (recall that data loss is incurred
only when a block is evicted from the cache and compressed).  Although the
best choice varies from one application to another, we suggest allocating
at least two layers of blocks (2 × (<em>nx</em> / 4) × (<em>ny</em> / 4)
blocks) for applications that stream through the array and perform stencil
computations such as gathering data from neighboring elements.  This allows
limiting the cache misses to compulsory ones.  If the <em>cache_size</em> parameter
is set to zero bytes, then a default size of √<em>n</em> blocks is used,
where <em>n</em> is the total number of blocks in the array.</p>
<p>The cache size can be set during construction, or can be set at a later
time via</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">set_cache_size</span><span class="p">(</span><span class="nb">bytes</span><span class="p">);</span> <span class="o">//</span> <span class="n">change</span> <span class="n">cache</span> <span class="n">size</span>
</pre></div>
</div>
<p>Note that if <em>bytes</em> = 0, then the array dimensions must have already been
specified for the default size to be computed correctly.  When the cache
is resized, it is first flushed if not already empty.  The cache can
also be flushed explicitly if desired by calling</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">flush_cache</span><span class="p">();</span> <span class="o">//</span> <span class="n">empty</span> <span class="n">cache</span> <span class="n">by</span> <span class="n">first</span> <span class="n">compressing</span> <span class="nb">any</span> <span class="n">modified</span> <span class="n">blocks</span>
</pre></div>
</div>
<p>To empty the cache without compressing any cached data, call</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">clear_cache</span><span class="p">();</span> <span class="o">//</span> <span class="n">empty</span> <span class="n">cache</span> <span class="n">without</span> <span class="n">compression</span>
</pre></div>
</div>
<p>To query the byte size of the cache, use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">size_t</span> <span class="n">cache_size</span><span class="p">();</span> <span class="o">//</span> <span class="n">actual</span> <span class="n">cache</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#high-level-c-interface">High-Level C Interface</a><ul>
<li><a class="reference internal" href="#simple-example">Simple Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#low-level-c-interface">Low-Level C Interface</a></li>
<li><a class="reference internal" href="#compressed-c-arrays">Compressed C++ Arrays</a><ul>
<li><a class="reference internal" href="#caching">Caching</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="zforp.html"
                        title="previous chapter">Fortran Bindings</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="zfpcmd.html"
                        title="next chapter">File Compressor</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="zfpcmd.html" title="File Compressor"
             >next</a> |</li>
        <li class="right" >
          <a href="zforp.html" title="Fortran Bindings"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2019, LLNL-CODE-663824.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>