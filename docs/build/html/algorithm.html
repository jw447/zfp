
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Algorithm &#8212; zfp 0.5.5 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Compression Modes" href="modes.html" />
    <link rel="prev" title="Installation" href="installation.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modes.html" title="Compression Modes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="algorithm">
<span id="id1"></span><h1>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h1>
<p>zfp uses two different algorithms to support <a class="reference internal" href="#algorithm-lossy"><span class="std std-ref">lossy</span></a>
and <a class="reference internal" href="#algorithm-lossless"><span class="std std-ref">lossless</span></a> compression.  These algorithms are
described in detail below.</p>
<div class="section" id="lossy-compression">
<span id="algorithm-lossy"></span><h2>Lossy Compression<a class="headerlink" href="#lossy-compression" title="Permalink to this headline">¶</a></h2>
<p>The zfp lossy compression scheme is based on the idea of breaking a
<em>d</em>-dimensional array into independent blocks of 4<sup>d</sup> values each,
e.g., 4 × 4 × 4 values in three dimensions.  Each block is
compressed/decompressed entirely independently from all other blocks.  In
this sense, zfp is similar to current hardware texture compression schemes
for image coding implemented on graphics cards and mobile devices.</p>
<p>The lossy compression scheme implemented in this version of zfp has evolved
from the method described in the <a class="reference internal" href="introduction.html#paper"><span class="std std-ref">original paper</span></a>, and can
conceptually be thought of as consisting of eight sequential steps (in
practice some steps are consolidated or exist only for illustrative
purposes):</p>
<blockquote>
<div><ol class="arabic simple">
<li>The <em>d</em>-dimensional array is partitioned into blocks of dimensions
4<sup>d</sup>.  If the array dimensions are not multiples of four, then
blocks near the boundary are padded to the next multiple of four.  This
padding is invisible to the application.</li>
<li>The independent floating-point values in a block are converted to what
is known as a block-floating-point representation, which uses a single,
common floating-point exponent for all 4<sup>d</sup> values.  The effect of
this conversion is to turn each floating-point value into a 31- or 63-bit
signed integer.  If the values in the block are all zero or are smaller
in magnitude than the fixed-accuracy tolerance (see below), then only a
single bit is stored with the block to indicate that it is “empty” and
expands to all zeros.  Note that the block-floating-point conversion and
empty-block encoding are not performed if the input data is represented
as integers rather than floating-point numbers.</li>
<li>The integers are decorrelated using a custom, high-speed, near orthogonal
transform similar to the discrete cosine transform used in JPEG image
coding.  The transform exploits separability and is implemented
efficiently in-place using the lifting scheme, requiring only
2.5 <em>d</em> integer additions and 1.5 <em>d</em> bit shifts by one per integer in
<em>d</em> dimensions.  If the data is “smooth,” then this transform will turn
most integers into small signed values clustered around zero.</li>
<li>The signed integer coefficients are reordered in a manner similar to
JPEG zig-zag ordering so that statistically they appear in a roughly
monotonically decreasing order.  Coefficients corresponding to low
frequencies tend to have larger magnitude and are listed first.  In 3D,
coefficients corresponding to frequencies <em>i</em>, <em>j</em>, <em>k</em> in the three
dimensions are ordered by <em>i</em> + <em>j</em> + <em>k</em> first and then by
<em>i</em><sup>2</sup> + <em>j</em><sup>2</sup> + <em>k</em><sup>2</sup>.</li>
<li>The two’s complement signed integers are converted to their negabinary
(base negative two) representation using one addition and one bit-wise
exclusive or per integer.  Because negabinary has no single dedicated
sign bit, these integers are subsequently treated as unsigned.  Unlike
sign-magnitude representations, the leftmost one-bit in negabinary
simultaneously encodes the sign and approximate magnitude of a number.
Moreover, unlike two’s complement, numbers small in magnitude have many
leading zeros in negabinary regardless of sign, which facilitates
encoding.</li>
<li>The bits that represent the list of 4<sup>d</sup> integers are transposed so
that instead of being ordered by coefficient they are ordered by bit
plane, from most to least significant bit.  Viewing each bit plane as
an unsigned integer, with the lowest bit corresponding to the lowest
frequency coefficient, the anticipation is that the first several of
these transposed integers are small, because the coefficients are
assumed to be ordered by magnitude.</li>
<li>The transform coefficients are compressed losslessly using embedded
coding by exploiting the property that the coefficients tend to have many
leading zeros that need not be encoded explicitly.  Each bit plane is
encoded in two parts, from lowest to highest bit.  First, the <em>n</em> lowest
bits are emitted verbatim, where <em>n</em> is the smallest number such that
the 4<sup>d</sup> − <em>n</em> highest bits in all previous bit planes are all
zero.  Initially, <em>n</em> = 0.  Then, a variable-length representation of the
remaining 4<sup>d</sup> − <em>n</em> bits, <em>x</em>, is encoded.  For such an integer
<em>x</em>, a single bit is emitted to indicate if <em>x</em> = 0, in which case we are
done with the current bit plane.  If not, then bits of <em>x</em> are emitted,
starting from the lowest bit, until a one-bit is emitted.  This triggers
another test whether this is the highest set bit of <em>x</em>, and the result
of this test is output as a single bit.  If not, then the procedure
repeats until all <em>m</em> of <em>x</em>’s value bits have been output, where
2<sup>m-1</sup> ≤ <em>x</em> &lt; 2<sup>m</sup>.  This can be thought of as a
run-length encoding of the zeros of <em>x</em>, where the run lengths are
expressed in unary.  The total number of value bits, <em>n</em>, in this bit
plane is then incremented by <em>m</em> before being passed to the next bit
plane, which is encoded by first emitting its <em>n</em> lowest bits.  The
assumption is that these bits correspond to <em>n</em> coefficients whose most
significant bits have already been output, i.e., these <em>n</em> bits are
essentially random and not compressible.  Following this, the remaining
4<sup>d</sup> − <em>n</em> bits of the bit plane are run-length encoded as
described above, which potentially results in <em>n</em> being increased.</li>
<li>The embedded coder emits one bit at a time, with each successive bit
potentially improving the accuracy of the approximation.  The early
bits are most important and have the greatest impact on accuracy,
with the last few bits providing very small changes.  The resulting
compressed bit stream can be truncated at any point and still allow for
a valid approximate reconstruction of the original block of values.
The final step truncates the bit stream in one of three ways: to a fixed
number of bits (the fixed-rate mode); after some fixed number of bit
planes have been encoded (the fixed-precision mode); or until a lowest
bit plane number has been encoded, as expressed in relation to the common
floating-point exponent within the block (the fixed-accuracy mode).</li>
</ol>
</div></blockquote>
<p>Various parameters are exposed for controlling the quality and compressed
size of a block, and can be specified by the user at a very fine
granularity.  These parameters are discussed <a class="reference internal" href="modes.html#modes"><span class="std std-ref">here</span></a>.</p>
</div>
<div class="section" id="lossless-compression">
<span id="algorithm-lossless"></span><h2>Lossless Compression<a class="headerlink" href="#lossless-compression" title="Permalink to this headline">¶</a></h2>
<p>The reversible (lossless) compression algorithm shares most steps with
the lossy algorithm.  The main differences are steps 2, 3, and 8, which are
the only sources of error.  Since step 2 may introduce loss in the conversion
to zfp’s block-floating-point representation, the reversible algorithm adds
a test to see if this conversion is lossless.  It does so by converting the
values back to the source format and testing the result for bitwise equality
with the uncompressed data.  If this test passes, then a modified
decorrelating transform is performed in step 3 that uses reversible integer
subtraction operations only.  Finally, step 8 is modified so that no one-bits
are truncated in the variable-length bit stream.  However, all least
significant bit planes with all-zero bits are truncated, and the number of
encoded bit planes is recorded in step 7.  As with lossy compression, a
floating-point block consisting of all (“positive”) zeros is represented as
a single bit, making it possible to efficiently encode sparse data.</p>
<p>If the block-floating-point transform is not lossless, then the reversible
compression algorithm falls back on a simpler scheme that reinterprets
floating-point values as integers via <em>type punning</em>.  This lossless
conversion from floating-point to integer data replaces step 2, and the
algorithm proceeds from there with the modified step 3.  Moreover, this
conversion ensures that special values like infinities, NaNs, and negative
zero are preserved.</p>
<p>The lossless algorithm handles integer data also, for which step 2 is omitted.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Algorithm</a><ul>
<li><a class="reference internal" href="#lossy-compression">Lossy Compression</a></li>
<li><a class="reference internal" href="#lossless-compression">Lossless Compression</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="modes.html"
                        title="next chapter">Compression Modes</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modes.html" title="Compression Modes"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2019, LLNL-CODE-663824.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>