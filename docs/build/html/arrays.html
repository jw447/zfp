
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Compressed Arrays &#8212; zfp 0.5.5 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Python Bindings" href="python.html" />
    <link rel="prev" title="Bit Stream API" href="bit-stream.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="python.html" title="Python Bindings"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="bit-stream.html" title="Bit Stream API"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="compressed-arrays">
<span id="arrays"></span><h1>Compressed Arrays<a class="headerlink" href="#compressed-arrays" title="Permalink to this headline">¶</a></h1>
<p>zfp’s compressed arrays are C++ classes, plus C wrappers around these
classes, that implement random-accessible single- and multi-dimensional
floating-point arrays whose storage size, specified in number of bits per
array element, is set by the user.  Such arbitrary storage is achieved via
zfp’s lossy <a class="reference internal" href="modes.html#mode-fixed-rate"><span class="std std-ref">fixed-rate compression</span></a> mode, by
partitioning each <em>d</em>-dimensional array into blocks of 4<sup>d</sup> values
and compressing each block to a fixed number of bits.  The more smoothly
the array values vary along each dimension, the more accurately zfp can
represent them.  In other words, these arrays are not suitable for
representing data where adjacent elements are not correlated.  Rather,
the expectation is that the array represents a regularly sampled and
predominantly continuous function, such as a temperature field in a physics
simulation.</p>
<p>The <em>rate</em>, measured in number of bits per array element, can be specified
in fractions of a bit (but see FAQs <a class="reference internal" href="faq.html#q-granularity"><span class="std std-ref">#12</span></a> and
<a class="reference internal" href="faq.html#q-rate"><span class="std std-ref">#18</span></a> for limitations).  Note that array dimensions need not
be multiples of four; zfp transparently handles partial blocks on array
boundaries.</p>
<p>The C++ templated array classes are implemented entirely as header files
that call the zfp C library to perform compression and decompression.
These arrays cache decompressed blocks to reduce the number of compression
and decompression calls.  Whenever an array value is read, the corresponding
block is first looked up in the cache, and if found the uncompressed value
is returned.  Otherwise the block is first decompressed and stored in the
cache.  Whenever an array element is written (whether actually modified or
not), a “dirty bit” is set with its cached block to indicate that the block
must be compressed back to persistent storage when evicted from the cache.</p>
<p>This section documents the public interface to the array classes, including
base classes and member accessor classes like proxy references/pointers,
iterators, and views.</p>
<p>The following sections are available:</p>
<ul class="simple">
<li><a class="reference internal" href="#array-classes"><span class="std std-ref">Array Classes</span></a></li>
<li><a class="reference internal" href="#caching"><span class="std std-ref">Caching</span></a></li>
<li><a class="reference internal" href="#serialization"><span class="std std-ref">Serialization</span></a></li>
<li><a class="reference internal" href="#references"><span class="std std-ref">References</span></a></li>
<li><a class="reference internal" href="#pointers"><span class="std std-ref">Pointers</span></a></li>
<li><a class="reference internal" href="#iterators"><span class="std std-ref">Iterators</span></a></li>
<li><a class="reference internal" href="#views"><span class="std std-ref">Views</span></a></li>
<li><a class="reference internal" href="#cfp"><span class="std std-ref">C bindings</span></a></li>
</ul>
<div class="section" id="array-classes">
<span id="id1"></span><h2>Array Classes<a class="headerlink" href="#array-classes" title="Permalink to this headline">¶</a></h2>
<p>Currently there are six array classes for 1D, 2D, and 3D arrays, each of
which can represent single- or double-precision values.  Although these
arrays store values in a form different from conventional single- and
double-precision floating point, the user interacts with the arrays via
floats and doubles.</p>
<p>The array classes can often serve as direct substitutes for C/C++
single- and multi-dimensional floating-point arrays and STL vectors, but
have the benefit of allowing fine control over storage size.  All classes
below belong to the <code class="xref cpp cpp-any docutils literal"><span class="pre">zfp</span></code> namespace.</p>
<div class="section" id="base-class">
<h3>Base Class<a class="headerlink" href="#base-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv2N3zfp5arrayE">
<span id="zfp::array"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">array</code><a class="headerlink" href="#_CPPv2N3zfp5arrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Virtual base class for common array functionality.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array4rateEv">
<span id="zfp::array::rateC"></span>double <code class="descclassname">array::</code><code class="descname">rate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array4rateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return rate in bits per value.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5array8set_rateEd">
<span id="zfp::array::set_rate__double"></span>double <code class="descclassname">array::</code><code class="descname">set_rate</code><span class="sig-paren">(</span>double <em>rate</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array8set_rateEd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set desired compression rate in bits per value.  Return the closest rate
supported.  See <a class="reference internal" href="faq.html#q-granularity"><span class="std std-ref">FAQ #12</span></a> and <a class="reference internal" href="faq.html#q-rate"><span class="std std-ref">FAQ #18</span></a>
for discussions of the rate granularity.  This method destroys the previous
contents of the array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array11clear_cacheEv">
<span id="zfp::array::clear_cacheC"></span><em class="property">virtual</em> void <code class="descclassname">array::</code><code class="descname">clear_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array11clear_cacheEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Empty cache without compressing modified cached blocks, i.e., discard any
cached updates to the array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array11flush_cacheEv">
<span id="zfp::array::flush_cacheC"></span><em class="property">virtual</em> void <code class="descclassname">array::</code><code class="descname">flush_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array11flush_cacheEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush cache by compressing all modified cached blocks back to persistent
storage and emptying the cache.  This method should be called before
writing the compressed representation of the array to disk, for instance.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array15compressed_sizeEv">
<span id="zfp::array::compressed_sizeC"></span>size_t <code class="descclassname">array::</code><code class="descname">compressed_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array15compressed_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return number of bytes of storage for the compressed data.  This amount
does not include the small overhead of other class members or the size
of the cache.  Rather, it reflects the size of the memory buffer
returned by <a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_dataEv" title="zfp::array::compressed_data"><code class="xref cpp cpp-func docutils literal"><span class="pre">compressed_data()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array15compressed_dataEv">
<span id="zfp::array::compressed_dataC"></span>uchar *<code class="descclassname">array::</code><code class="descname">compressed_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array15compressed_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return pointer to compressed data for read or write access.  The size
of the buffer is given by <a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_sizeEv" title="zfp::array::compressed_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">compressed_size()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array14dimensionalityEv">
<span id="zfp::array::dimensionalityC"></span>uint <code class="descclassname">array::</code><code class="descname">dimensionality</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array14dimensionalityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the dimensionality (1, 2, or 3) of the array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array11scalar_typeEv">
<span id="zfp::array::scalar_typeC"></span>zfp_type <code class="descclassname">array::</code><code class="descname">scalar_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array11scalar_typeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the underlying scalar type (<a class="reference internal" href="high-level-api.html#c.zfp_type" title="zfp_type"><code class="xref c c-type docutils literal"><span class="pre">zfp_type</span></code></a>) of the array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array10get_headerEv">
<span id="zfp::array::get_headerC"></span><a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a>::<a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header">header</a> <code class="descclassname">array::</code><code class="descname">get_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array10get_headerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a short fixed-length <a class="reference internal" href="#header"><span class="std std-ref">header</span></a> describing the scalar
type, dimensions, and rate associated with the array.
An <a class="reference internal" href="#_CPPv2N3zfp5array6header9exceptionE" title="zfp::array::header::exception"><code class="xref cpp cpp-class docutils literal"><span class="pre">array::header::exception</span></code></a> is thrown if the header cannot
describe the array.</p>
</dd></dl>

<span class="target" id="array-factory"></span><dl class="function">
<dt id="_CPPv2N3zfp5array9constructERKN5array6headerEPK5uchar6size_t">
<span id="zfp::array::construct__array::headerCR.ucharCP.s"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a> *<code class="descclassname">array::</code><code class="descname">construct</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a>::<a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header">header</a> &amp;<em>h</em>, <em class="property">const</em> uchar *<em>buffer</em> = 0, size_t <em>buffer_size_bytes</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array9constructERKN5array6headerEPK5uchar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a compressed-array object whose scalar type, dimensions, and rate
are given by the header <em>h</em>.  Return a pointer to the base class upon
success.  The optional <em>buffer</em> points to compressed data that, when passed,
is copied into the array.  If <em>buffer</em> is absent, the array is default
initialized with all zeroes.  The optional <em>buffer_size_bytes</em> argument
specifies the buffer length in bytes.  When passed, a comparison is made to
ensure that the buffer size is at least as large as the size implied by
the header.  If this function fails for any reason, an
<a class="reference internal" href="#_CPPv2N3zfp5array6header9exceptionE" title="zfp::array::header::exception"><code class="xref cpp cpp-class docutils literal"><span class="pre">array::header::exception</span></code></a> is thrown.</p>
</dd></dl>

</div>
<div class="section" id="common-methods">
<h3>Common Methods<a class="headerlink" href="#common-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are common to 1D, 2D, and 3D arrays, but are implemented
in the array class specific to each dimensionality rather than in the base
class.</p>
<dl class="function">
<dt id="_CPPv2NK3zfp5array4sizeEv">
<span id="zfp::array::sizeC"></span>size_t <code class="descclassname">array::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Total number of elements in array, e.g., <em>nx</em> × <em>ny</em> × <em>nz</em> for
3D arrays.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array10cache_sizeEv">
<span id="zfp::array::cache_sizeC"></span>size_t <code class="descclassname">array::</code><code class="descname">cache_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array10cache_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the cache size in number of bytes.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5array14set_cache_sizeE6size_t">
<span id="zfp::array::set_cache_size__s"></span>void <code class="descclassname">array::</code><code class="descname">set_cache_size</code><span class="sig-paren">(</span>size_t <em>csize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array14set_cache_sizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set minimum cache size in bytes.  The actual size is always a power of two
bytes and consists of at least one block.  If <em>csize</em> is zero, then a
default cache size is used, which requires the array dimensions to be known.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5array3getEP6Scalar">
<span id="zfp::array::get__ScalarPC"></span>void <code class="descclassname">array::</code><code class="descname">get</code><span class="sig-paren">(</span>Scalar *<em>p</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5array3getEP6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decompress entire array and store at <em>p</em>, for which sufficient storage must
have been allocated.  The uncompressed array is assumed to be contiguous
(with default strides) and stored in the usual “row-major” order, i.e., with
<em>x</em> varying faster than <em>y</em> and <em>y</em> varying faster than <em>z</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5array3setEPK6Scalar">
<span id="zfp::array::set__ScalarCP"></span>void <code class="descclassname">array::</code><code class="descname">set</code><span class="sig-paren">(</span><em class="property">const</em> Scalar *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array3setEPK6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize array by copying and compressing data stored at <em>p</em>.  The
uncompressed data is assumed to be stored as in the <a class="reference internal" href="#_CPPv2NK3zfp5array3getEP6Scalar" title="zfp::array::get"><code class="xref cpp cpp-func docutils literal"><span class="pre">get()</span></code></a>
method.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp5arrayixE4uint">
<span id="zfp::array::subscript-operator__uintC"></span>Scalar <code class="descclassname">array::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp5arrayixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar stored at given flat index (inspector).  For a 3D array,
<code class="code docutils literal"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">nx</span> <span class="pre">*</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">ny</span> <span class="pre">*</span> <span class="pre">z)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5arrayixE4uint">
<span id="zfp::array::subscript-operator__uint"></span>reference <code class="descclassname">array::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5arrayixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return <a class="reference internal" href="#references"><span class="std std-ref">proxy reference</span></a> to scalar stored at given flat
index (mutator).  For a 3D array, <code class="code docutils literal"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">nx</span> <span class="pre">*</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">ny</span> <span class="pre">*</span> <span class="pre">z)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5array5beginEv">
<span id="zfp::array::begin"></span>iterator <code class="descclassname">array::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array5beginEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return iterator to beginning of array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp5array3endEv">
<span id="zfp::array::end"></span>iterator <code class="descclassname">array::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp5array3endEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return iterator to end of array.  As with STL iterators, the end points
to a virtual element just past the last valid array element.</p>
</dd></dl>

</div>
<div class="section" id="d-2d-and-3d-arrays">
<h3>1D, 2D, and 3D Arrays<a class="headerlink" href="#d-2d-and-3d-arrays" title="Permalink to this headline">¶</a></h3>
<p>Below are classes and methods specific to each array dimensionality and
template scalar type (<code class="code docutils literal"><span class="pre">float</span></code> or <code class="code docutils literal"><span class="pre">double</span></code>).  Since the classes
and methods share obvious similarities regardless of dimensionality, only
one generic description for all dimensionalities is provided.</p>
<p>Note: In the class declarations below, the class template for the scalar
type is omitted for readability, e.g.,
<code class="code docutils literal"><span class="pre">class</span> <span class="pre">array1</span></code> is used as shorthand for
<code class="code docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">Scalar&gt;</span> <span class="pre">class</span> <span class="pre">array1</span></code>.  Wherever the type
<code class="code docutils literal"><span class="pre">Scalar</span></code> appears, it refers to this template argument.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array1E">
<span id="zfp::array1"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">array1</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a><a class="headerlink" href="#_CPPv2N3zfp6array1E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array2E">
<span id="zfp::array2"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">array2</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a><a class="headerlink" href="#_CPPv2N3zfp6array2E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array3E">
<span id="zfp::array3"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">array3</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a><a class="headerlink" href="#_CPPv2N3zfp6array3E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a 1D/2D/3D array that inherits basic functionality from the generic
<a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array"><code class="xref cpp cpp-class docutils literal"><span class="pre">array</span></code></a> base class.  The template argument, <code class="xref cpp cpp-type docutils literal"><span class="pre">Scalar</span></code>,
specifies the floating type returned for array elements.  The suffixes
<code class="code docutils literal"><span class="pre">f</span></code> and <code class="code docutils literal"><span class="pre">d</span></code> can also be appended to each class to indicate float
or double type, e.g., <code class="xref cpp cpp-class docutils literal"><span class="pre">array1f</span></code> is a synonym for
<code class="xref cpp cpp-class docutils literal"><span class="pre">array1&lt;float&gt;</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp8arrayANYE">
<span id="zfp::arrayANY"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">arrayANY</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a><a class="headerlink" href="#_CPPv2N3zfp8arrayANYE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fictitious class used to refer to any one of <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1"><code class="xref cpp cpp-class docutils literal"><span class="pre">array1</span></code></a>,
<a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2"><code class="xref cpp cpp-class docutils literal"><span class="pre">array2</span></code></a>, and <a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3"><code class="xref cpp cpp-class docutils literal"><span class="pre">array3</span></code></a>.  This class is not part of
the zfp API.</p>
</dd></dl>

<span class="target" id="array-ctor-default"></span><dl class="function">
<dt id="_CPPv2N3zfp6array16array1Ev">
<span id="zfp::array1::array1"></span><code class="descclassname">array1::</code><code class="descname">array1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array16array1Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array26array2Ev">
<span id="zfp::array2::array2"></span><code class="descclassname">array2::</code><code class="descname">array2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array26array2Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array36array3Ev">
<span id="zfp::array3::array3"></span><code class="descclassname">array3::</code><code class="descname">array3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array36array3Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor.  Creates an empty array whose size and rate are both
zero.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The default constructor is useful when the array size or rate is not known at
time of construction.  Before the array can become usable, however, it must
be <a class="reference internal" href="#array-resize"><span class="std std-ref">resized</span></a> and its rate must be set via
<a class="reference internal" href="#_CPPv2N3zfp5array8set_rateEd" title="zfp::array::set_rate"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_rate()</span></code></a>.  These two tasks can be performed in either order.
Furthermore, the desired cache size should be set using
<a class="reference internal" href="#_CPPv2N3zfp5array14set_cache_sizeE6size_t" title="zfp::array::set_cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_cache_size()</span></code></a>, as the default constructor creates a
cache that holds only one zfp block, i.e., the minimum possible.</p>
</div>
<span class="target" id="array-ctor"></span><dl class="function">
<dt id="_CPPv2N3zfp6array16array1E4uintdPK6Scalar6size_t">
<span id="zfp::array1::array1__uint.double.ScalarCP.s"></span><code class="descclassname">array1::</code><code class="descname">array1</code><span class="sig-paren">(</span>uint <em>n</em>, double <em>rate</em>, <em class="property">const</em> Scalar *<em>p</em> = 0, size_t <em>csize</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array16array1E4uintdPK6Scalar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array26array2E4uint4uintdPK6Scalar6size_t">
<span id="zfp::array2::array2__uint.uint.double.ScalarCP.s"></span><code class="descclassname">array2::</code><code class="descname">array2</code><span class="sig-paren">(</span>uint <em>nx</em>, uint <em>ny</em>, double <em>rate</em>, <em class="property">const</em> Scalar *<em>p</em> = 0, size_t <em>csize</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array26array2E4uint4uintdPK6Scalar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array36array3E4uint4uint4uintdPK6Scalar6size_t">
<span id="zfp::array3::array3__uint.uint.uint.double.ScalarCP.s"></span><code class="descclassname">array3::</code><code class="descname">array3</code><span class="sig-paren">(</span>uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em>, double <em>rate</em>, <em class="property">const</em> Scalar *<em>p</em> = 0, size_t <em>csize</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array36array3E4uint4uint4uintdPK6Scalar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor of array with dimensions <em>n</em> (1D), <em>nx</em> × <em>ny</em> (2D), or
<em>nx</em> × <em>ny</em> × <em>nz</em> (3D) using <em>rate</em> bits per value, at least
<em>csize</em> bytes of cache, and optionally initialized from flat, uncompressed
array <em>p</em>.  If <em>csize</em> is zero, a default cache size is chosen.</p>
</dd></dl>

<span class="target" id="array-ctor-header"></span><dl class="function">
<dt id="_CPPv2N3zfp6array16array1ERKN5array6headerEPK5uchar6size_t">
<span id="zfp::array1::array1__array::headerCR.ucharCP.s"></span><code class="descclassname">array1::</code><code class="descname">array1</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a>::<a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header">header</a> &amp;<em>h</em>, <em class="property">const</em> uchar *<em>buffer</em> = 0, size_t <em>buffer_size_bytes</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array16array1ERKN5array6headerEPK5uchar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array26array2ERKN5array6headerEPK5uchar6size_t">
<span id="zfp::array2::array2__array::headerCR.ucharCP.s"></span><code class="descclassname">array2::</code><code class="descname">array2</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a>::<a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header">header</a> &amp;<em>h</em>, <em class="property">const</em> uchar *<em>buffer</em> = 0, size_t <em>buffer_size_bytes</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array26array2ERKN5array6headerEPK5uchar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array36array3ERKN5array6headerEPK5uchar6size_t">
<span id="zfp::array3::array3__array::headerCR.ucharCP.s"></span><code class="descclassname">array3::</code><code class="descname">array3</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array">array</a>::<a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header">header</a> &amp;<em>h</em>, <em class="property">const</em> uchar *<em>buffer</em> = 0, size_t <em>buffer_size_bytes</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array36array3ERKN5array6headerEPK5uchar6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor from previously <a class="reference internal" href="#serialization"><span class="std std-ref">serialized</span></a> compressed
array.  Struct <a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header"><code class="xref cpp cpp-type docutils literal"><span class="pre">array::header</span></code></a> contains array metadata, while
optional <em>buffer</em> points to the compressed data that is to be copied to
the array.  The optional <em>buffer_size_bytes</em> argument specifies the
<em>buffer</em> length.  If the constructor fails, an
<a class="reference internal" href="#_CPPv2N3zfp5array6header9exceptionE" title="zfp::array::header::exception"><code class="xref cpp cpp-class docutils literal"><span class="pre">array::header::exception</span></code></a> is thrown.
See <a class="reference internal" href="#_CPPv2N3zfp5array9constructERKN5array6headerEPK5uchar6size_t" title="zfp::array::construct"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::construct()</span></code></a> for further details on the <em>buffer</em> and
<em>buffer_size_bytes</em> arguments.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array16array1ERK6array1">
<span id="zfp::array1::array1__array1CR"></span><code class="descclassname">array1::</code><code class="descname">array1</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array16array1Ev" title="zfp::array1::array1">array1</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array16array1ERK6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array26array2ERK6array2">
<span id="zfp::array2::array2__array2CR"></span><code class="descclassname">array2::</code><code class="descname">array2</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array26array2Ev" title="zfp::array2::array2">array2</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array26array2ERK6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array36array3ERK6array3">
<span id="zfp::array3::array3__array3CR"></span><code class="descclassname">array3::</code><code class="descname">array3</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array36array3Ev" title="zfp::array3::array3">array3</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array36array3ERK6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor.  Performs a deep copy.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array1D0Ev">
<span id="zfp::array1::~array1"></span><em class="property">virtual</em> <code class="descclassname">array1::</code><code class="descname">~array1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array1D0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array2D0Ev">
<span id="zfp::array2::~array2"></span><em class="property">virtual</em> <code class="descclassname">array2::</code><code class="descname">~array2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array2D0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array3D0Ev">
<span id="zfp::array3::~array3"></span><em class="property">virtual</em> <code class="descclassname">array3::</code><code class="descname">~array3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array3D0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Virtual destructor (allows for inheriting from zfp arrays).</p>
</dd></dl>

<span class="target" id="array-copy"></span><dl class="function">
<dt id="_CPPv2N3zfp6array1aSERK6array1">
<span id="zfp::array1::assign-operator__array1CR"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> &amp;<code class="descclassname">array1::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array1aSERK6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array2aSERK6array2">
<span id="zfp::array2::assign-operator__array2CR"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> &amp;<code class="descclassname">array2::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array2aSERK6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array3aSERK6array3">
<span id="zfp::array3::assign-operator__array3CR"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> &amp;<code class="descclassname">array3::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> &amp;<em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array3aSERK6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator.  Performs a deep copy.</p>
</dd></dl>

<span class="target" id="array-dims"></span><dl class="function">
<dt id="_CPPv2NK3zfp6array26size_xEv">
<span id="zfp::array2::size_xC"></span>uint <code class="descclassname">array2::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array26size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array26size_yEv">
<span id="zfp::array2::size_yC"></span>uint <code class="descclassname">array2::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array26size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array36size_xEv">
<span id="zfp::array3::size_xC"></span>uint <code class="descclassname">array3::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array36size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array36size_yEv">
<span id="zfp::array3::size_yC"></span>uint <code class="descclassname">array3::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array36size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array36size_zEv">
<span id="zfp::array3::size_zC"></span>uint <code class="descclassname">array3::</code><code class="descname">size_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array36size_zEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return array dimensions.</p>
</dd></dl>

<span class="target" id="array-resize"></span><dl class="function">
<dt id="_CPPv2N3zfp6array16resizeE4uintb">
<span id="zfp::array1::resize__uint.b"></span>void <code class="descclassname">array1::</code><code class="descname">resize</code><span class="sig-paren">(</span>uint <em>n</em>, bool <em>clear</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array16resizeE4uintb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array26resizeE4uint4uintb">
<span id="zfp::array2::resize__uint.uint.b"></span>void <code class="descclassname">array2::</code><code class="descname">resize</code><span class="sig-paren">(</span>uint <em>nx</em>, uint <em>ny</em>, bool <em>clear</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array26resizeE4uint4uintb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array36resizeE4uint4uint4uintb">
<span id="zfp::array3::resize__uint.uint.uint.b"></span>void <code class="descclassname">array3::</code><code class="descname">resize</code><span class="sig-paren">(</span>uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em>, bool <em>clear</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array36resizeE4uint4uint4uintb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize the array (all previously stored data will be lost).  If <em>clear</em> is
true, then the array elements are all initialized to zero.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is often desirable (though not a requirement) to also set the cache size
when resizing an array, e.g., in proportion to the array size;
see <a class="reference internal" href="#_CPPv2N3zfp5array14set_cache_sizeE6size_t" title="zfp::array::set_cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_cache_size()</span></code></a>.  This is particularly important when
the array is default constructed, which initializes the cache size to the
minimum possible of only one zfp block.</p>
</div>
<span class="target" id="array-accessor"></span><dl class="function">
<dt id="_CPPv2NK3zfp6array1clE4uint">
<span id="zfp::array1::call-operator__uintC"></span>Scalar <code class="descclassname">array1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array2clE4uint4uint">
<span id="zfp::array2::call-operator__uint.uintC"></span>Scalar <code class="descclassname">array2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array3clE4uint4uint4uint">
<span id="zfp::array3::call-operator__uint.uint.uintC"></span>Scalar <code class="descclassname">array3::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array3clE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar stored at multi-dimensional index given by <em>i</em>, <em>j</em>, and <em>k</em>
(inspector).</p>
</dd></dl>

<span class="target" id="lvref"></span><dl class="function">
<dt id="_CPPv2N3zfp6array1clE4uint">
<span id="zfp::array1::call-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array19referenceE" title="zfp::array1::reference">reference</a> <code class="descclassname">array1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array2clE4uint4uint">
<span id="zfp::array2::call-operator__uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array3clE4uint4uint4uint">
<span id="zfp::array3::call-operator__uint.uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array3clE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return <a class="reference internal" href="#references"><span class="std std-ref">proxy reference</span></a> to scalar stored at
multi-dimensional index given by <em>i</em>, <em>j</em>, and <em>k</em> (mutator).</p>
</dd></dl>

</div>
</div>
<div class="section" id="caching">
<span id="id2"></span><h2>Caching<a class="headerlink" href="#caching" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, the array classes maintain a software write-back cache
of at least one uncompressed block.  When a block in this cache is evicted
(e.g., due to a conflict), it is compressed back to permanent storage only
if it was modified while stored in the cache.</p>
<p>The size cache to use is specified by the user and is an important
parameter that needs careful consideration in order to balance the extra
memory usage, performance, and quality (recall that data loss is incurred
only when a block is evicted from the cache and compressed).  Although the
best choice varies from one application to another, we suggest allocating
at least two “layers” of blocks, e.g., 2 × (<em>nx</em> / 4) × (<em>ny</em> / 4)
blocks for 3D arrays, for applications that stream through the array and
perform stencil computations such as gathering data from neighboring elements.
This allows limiting the cache misses to compulsory ones.  If the <em>csize</em>
parameter provided to the constructor is set to zero bytes, then a default
cache size of at least √<em>n</em> blocks is used, where <em>n</em> is the total
number of blocks contained in the array.</p>
<p>The cache size can be set during construction, or can be set at a later
time via <a class="reference internal" href="#_CPPv2N3zfp5array14set_cache_sizeE6size_t" title="zfp::array::set_cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_cache_size()</span></code></a>.  Note that if <em>csize</em> = 0, then
the array dimensions must have already been specified for the default size
to be computed correctly.  When the cache is resized, it is first flushed
if not already empty.  The cache can also be flushed explicitly if desired
by calling <a class="reference internal" href="#_CPPv2NK3zfp5array11flush_cacheEv" title="zfp::array::flush_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::flush_cache()</span></code></a>.  To empty the cache without
compressing any cached data, call <a class="reference internal" href="#_CPPv2NK3zfp5array11clear_cacheEv" title="zfp::array::clear_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::clear_cache()</span></code></a>.  To query
the byte size of the cache, use <a class="reference internal" href="#_CPPv2NK3zfp5array10cache_sizeEv" title="zfp::array::cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::cache_size()</span></code></a>.</p>
<p>By default, a direct-mapped cache is used with a hash function that maps
block indices to cache lines.  A faster but more collision prone hash
can be enabled by defining the preprocessor macro
<a class="reference internal" href="installation.html#c.ZFP_WITH_CACHE_FAST_HASH" title="ZFP_WITH_CACHE_FAST_HASH"><code class="xref c c-macro docutils literal"><span class="pre">ZFP_WITH_CACHE_FAST_HASH</span></code></a>.
A two-way skew-associative cache is enabled by defining the preprocessor
macro <a class="reference internal" href="installation.html#c.ZFP_WITH_CACHE_TWOWAY" title="ZFP_WITH_CACHE_TWOWAY"><code class="xref c c-macro docutils literal"><span class="pre">ZFP_WITH_CACHE_TWOWAY</span></code></a>.</p>
</div>
<div class="section" id="serialization">
<span id="index-0"></span><span id="id3"></span><h2>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h2>
<p>zfp’s compressed arrays can be serialized to sequential, contiguous
storage and later recovered back into an object, for example, to support
I/O of compressed-array objects.  Two pieces of information are needed
to describe a zfp array: the raw compressed data, obtained via
<a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_dataEv" title="zfp::array::compressed_data"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::compressed_data()</span></code></a> and <a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_sizeEv" title="zfp::array::compressed_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::compressed_size()</span></code></a>,
and a <a class="reference internal" href="#header"><span class="std std-ref">header</span></a> that describes the array scalar type,
dimensions, and rate, obtained via <a class="reference internal" href="#_CPPv2NK3zfp5array10get_headerEv" title="zfp::array::get_header"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::get_header()</span></code></a>.
The user may concatenate the header and compressed data to form a
fixed-rate byte stream that can be read by the zfp
<a class="reference internal" href="zfpcmd.html#zfpcmd"><span class="std std-ref">command-line tool</span></a>.  When serializing the array,
the user should first call <a class="reference internal" href="#_CPPv2NK3zfp5array11flush_cacheEv" title="zfp::array::flush_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::flush_cache()</span></code></a> before
accessing the raw compressed data.</p>
<p>There are two primary ways to construct a compressed-array object from
compressed data: via array-specific <a class="reference internal" href="#array-ctor-header"><span class="std std-ref">constructors</span></a>
and via a generic <a class="reference internal" href="#array-factory"><span class="std std-ref">factory function</span></a>:</p>
<ul>
<li><p class="first">When the array scalar type (i.e., <code class="code docutils literal"><span class="pre">float</span></code> or <code class="code docutils literal"><span class="pre">double</span></code>) and
dimensionality (i.e., 1D, 2D, or 3D) are already known, the corresponding
array <a class="reference internal" href="#array-ctor-header"><span class="std std-ref">constructor</span></a> may be used.  If the
scalar type and dimensionality stored in the header do not match
the array class, then an <a class="reference internal" href="#exception"><span class="std std-ref">exception</span></a> is thrown.</p>
</li>
<li><p class="first">zfp provides a <a class="reference internal" href="#array-factory"><span class="std std-ref">factory function</span></a> that can be used
when the serialized array type is unknown but described in the header.
This function returns a pointer to the abstract base class,
<a class="reference internal" href="#_CPPv2N3zfp5arrayE" title="zfp::array"><code class="xref cpp cpp-class docutils literal"><span class="pre">array</span></code></a>, which the caller should dynamically cast to the
corresponding derived array, e.g., by examining
<a class="reference internal" href="#_CPPv2NK3zfp5array11scalar_typeEv" title="zfp::array::scalar_type"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::scalar_type()</span></code></a> and <a class="reference internal" href="#_CPPv2NK3zfp5array14dimensionalityEv" title="zfp::array::dimensionality"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::dimensionality()</span></code></a>.</p>
<p>The (static) factory function is made available by including
<code class="file docutils literal"><span class="pre">zfpfactory.h</span></code>.  This header must be included <em>after</em> first
including the header files associated with the compressed arrays, i.e.,
<code class="file docutils literal"><span class="pre">zfparray1.h</span></code>, <code class="file docutils literal"><span class="pre">zfparray2.h</span></code>, and <code class="file docutils literal"><span class="pre">zfparray3.h</span></code>.
Only those arrays whose header files are included can be constructed by
the factory function.  This design decouples the array classes so that
they may be included independently, for example, to reduce compilation
time.</p>
</li>
</ul>
<p>Both types of deserialization functions accept an <a class="reference internal" href="#_CPPv2N3zfp5array6headerE" title="zfp::array::header"><code class="xref cpp cpp-class docutils literal"><span class="pre">array::header</span></code></a>,
an optional buffer holding compressed data, and an optional buffer size.
If this buffer is provided, then a separate copy of the compressed data it
holds is made, which is used to initialize the array.  If the optional buffer
size is also provided, then these functions throw an exception if the size
is not at least as large as is expected from the metadata stored in the
header.  This safeguard is implemented to avoid accessing memory beyond the
end of the buffer.  If no buffer is provided, then all array elements are
default initialized to zero.  The array may later be initialized by directly
reading/copying data into the space pointed to by
<a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_dataEv" title="zfp::array::compressed_data"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::compressed_data()</span></code></a>.</p>
<p>Below is a simple example of serialization of a 3D compressed array of doubles
(error checking has been omitted for clarity):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">a</span><span class="o">.</span><span class="n">flush_cache</span><span class="p">();</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array</span><span class="p">::</span><span class="n">header</span> <span class="n">h</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_header</span><span class="p">();</span>
<span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="n">fwrite</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">compressed_data</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">compressed_size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
</pre></div>
</div>
<p>We may then deserialize this array using the factory function.  The following
example reads the compressed data directly into the array without making a
copy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array</span><span class="p">::</span><span class="n">header</span> <span class="n">h</span><span class="p">;</span>
<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">zfp</span><span class="p">::</span><span class="n">array</span><span class="p">::</span><span class="n">construct</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">compressed_data</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">compressed_size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dimensionality</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">scalar_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">zfp_type_double</span><span class="p">);</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="header">
<span id="index-1"></span><span id="id4"></span><h3>Header<a class="headerlink" href="#header" title="Permalink to this headline">¶</a></h3>
<p>Short 12-byte headers are used to describe array metadata and compression
parameters when serializing a compressed array.  This header is the same as
supported by the <a class="reference internal" href="high-level-api.html#c.zfp_read_header" title="zfp_read_header"><code class="xref c c-func docutils literal"><span class="pre">zfp_read_header()</span></code></a> and <a class="reference internal" href="high-level-api.html#c.zfp_write_header" title="zfp_write_header"><code class="xref c c-func docutils literal"><span class="pre">zfp_write_header()</span></code></a>
functions, using <a class="reference internal" href="high-level-api.html#c.ZFP_HEADER_FULL" title="ZFP_HEADER_FULL"><code class="xref c c-macro docutils literal"><span class="pre">ZFP_HEADER_FULL</span></code></a> to indicate that complete metadata
is to be stored in the header.  The header is also compatible with the zfp
<a class="reference internal" href="zfpcmd.html#zfpcmd"><span class="std std-ref">command-line tool</span></a>.  Processing of the header may result in an
<a class="reference internal" href="#exception"><span class="std std-ref">exception</span></a> being thrown.</p>
<dl class="class">
<dt id="_CPPv2N3zfp5array6headerE">
<span id="zfp::array::header"></span><em class="property">class </em><code class="descclassname">array::</code><code class="descname">header</code><a class="headerlink" href="#_CPPv2N3zfp5array6headerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The header stores information such as scalar type, array dimensions, and
rate.  Compressed-array headers are always 96 bits long.  These bits are
stored in the <code class="code docutils literal"><span class="pre">header::buffer</span></code> field, the only field represented
in the header.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">header</span> <span class="p">{</span>
  <span class="n">uchar</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BITS_TO_BYTES</span><span class="p">(</span><span class="n">ZFP_HEADER_SIZE_BITS</span><span class="p">)];</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="exception"></span><dl class="class">
<dt id="_CPPv2N3zfp5array6header9exceptionE">
<span id="zfp::array::header::exception"></span><em class="property">class </em><code class="descclassname">array::header::</code><code class="descname">exception</code> : <em class="property">public</em> std::runtime_error<a class="headerlink" href="#_CPPv2N3zfp5array6header9exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compressed arrays can throw this exception upon serialization, when forming
a header via <a class="reference internal" href="#_CPPv2NK3zfp5array10get_headerEv" title="zfp::array::get_header"><code class="xref cpp cpp-func docutils literal"><span class="pre">get_header()</span></code></a>, or deserialization, when constructing
a compressed array via its <a class="reference internal" href="#array-ctor-header"><span class="std std-ref">constructor</span></a> or
<a class="reference internal" href="#array-factory"><span class="std std-ref">factory function</span></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Compressed-array headers use zfp’s most concise representation of only
96 bits.  Such short headers support compressed blocks up to 2048 bits long.
This implies that the highest rate for 3D arrays is 2048/4<sup>3</sup> = 32
bits/value.  3D arrays whose rate exceeds 32 cannot be serialized using
<a class="reference internal" href="#_CPPv2NK3zfp5array10get_headerEv" title="zfp::array::get_header"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::get_header()</span></code></a>, which for such arrays throws an exception.
1D and 2D arrays do not suffer from this limitation.</p>
</div>
</div>
</div>
<div class="section" id="references">
<span id="index-2"></span><span id="id5"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N3zfp6array19referenceE">
<span id="zfp::array1::reference"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">reference</code><a class="headerlink" href="#_CPPv2N3zfp6array19referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array29referenceE">
<span id="zfp::array2::reference"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">reference</code><a class="headerlink" href="#_CPPv2N3zfp6array29referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array39referenceE">
<span id="zfp::array3::reference"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">reference</code><a class="headerlink" href="#_CPPv2N3zfp6array39referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Array <a class="reference internal" href="#lvref"><span class="std std-ref">indexing operators</span></a> must return lvalue references that
alias array elements and serve as vehicles for assigning values to those
elements.  Unfortunately, zfp cannot simply return a standard C++ reference
(e.g., <code class="code docutils literal"><span class="pre">float&amp;</span></code>) to an uncompressed array element since the element in
question may exist only in compressed form or as a transient cached entry that
may be invalidated (evicted) at any point.</p>
<p>To address this, zfp provides <em>proxies</em> for references and pointers that
act much like regular references and pointers, but which refer to elements
by array and index rather than by memory address.  When assigning to an
array element through such a proxy reference or pointer, the corresponding
element is decompressed to cache (if not already cached) and immediately
updated.</p>
<p>zfp references may be freely passed to other functions and they remain
valid during the lifetime of the corresponding array element.  One may also
take the address of a reference, which yields a
<a class="reference internal" href="#pointers"><span class="std std-ref">proxy pointer</span></a>.  When a reference appears as an rvalue in
an expression, it is implicitly converted to a value.</p>
<p>The following operators are defined for zfp references.  They act on the
referenced array element in the same manner as operators defined for
conventional C++ references.</p>
<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referenceaSERK9reference">
<span id="zfp::arrayANY::reference::assign-operator__referenceCR"></span>reference <code class="descclassname">reference::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> reference &amp;<em>ref</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referenceaSERK9reference" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment (copy) operator.  The referenced element, <em>elem</em>, is assigned the
value stored at the element referenced by <em>ref</em>.  Return <code class="code docutils literal"><span class="pre">*this</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referenceaSE6Scalar">
<span id="zfp::arrayANY::reference::assign-operator__Scalar"></span>reference <code class="descclassname">reference::</code><code class="descname">operator=</code><span class="sig-paren">(</span>Scalar <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referenceaSE6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referencepLE6Scalar">
<span id="zfp::arrayANY::reference::add-assign-operator__Scalar"></span>reference <code class="descclassname">reference::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>Scalar <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referencepLE6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referencemIE6Scalar">
<span id="zfp::arrayANY::reference::sub-assign-operator__Scalar"></span>reference <code class="descclassname">reference::</code><code class="descname">operator-=</code><span class="sig-paren">(</span>Scalar <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referencemIE6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referencemLE6Scalar">
<span id="zfp::arrayANY::reference::mul-assign-operator__Scalar"></span>reference <code class="descclassname">reference::</code><code class="descname">operator*=</code><span class="sig-paren">(</span>Scalar <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referencemLE6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referencedVE6Scalar">
<span id="zfp::arrayANY::reference::div-assign-operator__Scalar"></span>reference <code class="descclassname">reference::</code><code class="descname">operator/=</code><span class="sig-paren">(</span>Scalar <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referencedVE6Scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment and compound assignment operators.  For a given operator
<code class="code docutils literal"><span class="pre">op</span></code>, update the referenced element, <em>elem</em>, via
<em>elem</em> <code class="code docutils literal"><span class="pre">op</span></code> <em>val</em>.  Return <code class="code docutils literal"><span class="pre">*this</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY9referenceanEv">
<span id="zfp::arrayANY::reference::and-operator"></span>pointer <code class="descclassname">reference::</code><code class="descname">operator&amp;</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY9referenceanEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return pointer to the referenced array element.</p>
</dd></dl>

<p>Finally, zfp proxy references serve as a building block for implementing
proxy <a class="reference internal" href="#pointers"><span class="std std-ref">pointers</span></a> and <a class="reference internal" href="#iterators"><span class="std std-ref">iterators</span></a>.</p>
</div>
<div class="section" id="pointers">
<span id="index-3"></span><span id="id6"></span><h2>Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N3zfp6array17pointerE">
<span id="zfp::array1::pointer"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">pointer</code><a class="headerlink" href="#_CPPv2N3zfp6array17pointerE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array27pointerE">
<span id="zfp::array2::pointer"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">pointer</code><a class="headerlink" href="#_CPPv2N3zfp6array27pointerE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array37pointerE">
<span id="zfp::array3::pointer"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">pointer</code><a class="headerlink" href="#_CPPv2N3zfp6array37pointerE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Similar to <a class="reference internal" href="#references"><span class="std std-ref">references</span></a>, zfp supports proxies for
pointers to individual array elements.  From the user’s perspective, such
pointers behave much like regular pointers to uncompressed data, e.g.,
instead of</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">float</span> <span class="n">a</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">];</span>     <span class="o">//</span> <span class="n">uncompressed</span> <span class="mi">2</span><span class="n">D</span> <span class="n">array</span> <span class="n">of</span> <span class="n">floats</span>
<span class="nb">float</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="o">//</span> <span class="n">point</span> <span class="n">to</span> <span class="n">first</span> <span class="n">array</span> <span class="n">element</span>
<span class="n">p</span><span class="p">[</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>           <span class="o">//</span> <span class="nb">set</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">*++</span><span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>            <span class="o">//</span> <span class="nb">set</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>one would write</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array2</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>       <span class="o">//</span> <span class="n">compressed</span> <span class="mi">2</span><span class="n">D</span> <span class="n">array</span> <span class="n">of</span> <span class="n">floats</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array2</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">::</span><span class="n">pointer</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="o">//</span> <span class="n">point</span> <span class="n">to</span> <span class="n">first</span> <span class="n">array</span> <span class="n">element</span>
<span class="n">p</span><span class="p">[</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                                <span class="o">//</span> <span class="nb">set</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">*++</span><span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                                 <span class="o">//</span> <span class="nb">set</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>However, even though zfp’s proxy pointers point to individual scalars,
they are associated with the array that those scalars are stored in, including
the array’s dimensionality.  Pointers into arrays of different dimensionality
have incompatible type.  Moreover, pointers to elements in different arrays
are incompatible.  For example, one cannot take the difference between
pointers into two different arrays.</p>
<p>Unlike zfp’s proxy references, its proxy pointers support traversing
arrays using conventional pointer arithmetic.  In particular, unlike the
<a class="reference internal" href="#iterators"><span class="std std-ref">iterators</span></a> below, zfp’s pointers are oblivious to the
fact that the compressed arrays are partitioned into blocks, and the pointers
traverse arrays element by element as though the arrays were flattened in
standard C row-major order.  That is, if <code class="code docutils literal"><span class="pre">p</span></code> points to the first
element of a 3D array <code class="code docutils literal"><span class="pre">a(nx,</span> <span class="pre">ny,</span> <span class="pre">nz)</span></code>, then
<code class="code docutils literal"><span class="pre">a(i,</span> <span class="pre">j,</span> <span class="pre">k)</span> <span class="pre">==</span> <span class="pre">p[i</span> <span class="pre">+</span> <span class="pre">nx</span> <span class="pre">*</span> <span class="pre">(j</span> <span class="pre">+</span> <span class="pre">ny</span> <span class="pre">*</span> <span class="pre">k)]</span></code>.  In other words, pointer
indexing follows the same order as flat array indexing
(see <a class="reference internal" href="#_CPPv2NK3zfp5arrayixE4uint" title="zfp::array::operator[]"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::operator[]()</span></code></a>).</p>
<p>A pointer remains valid during the lifetime of the scalar that it points to.
Like conventional pointers, proxy pointers can be passed to other functions
and manipulated there, for instance by passing the pointer by reference via
<code class="code docutils literal"><span class="pre">pointer&amp;</span></code>.</p>
<p>The following operators are defined for proxy pointers.  Below <em>p</em> refers
to the pointer being acted upon.</p>
<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointeraSERK7pointer">
<span id="zfp::arrayANY::pointer::assign-operator__pointerCR"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> pointer &amp;<em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointeraSERK7pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator.  Assigns <em>q</em> to <em>p</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointermlEv">
<span id="zfp::arrayANY::pointer::mul-operatorC"></span>reference <code class="descclassname">pointer::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointermlEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dereference operator.  Return proxy reference to the value pointed to by
<em>p</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointerixE9ptrdiff_t">
<span id="zfp::arrayANY::pointer::subscript-operator__ptrdiff_tC"></span>reference <code class="descclassname">pointer::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>ptrdiff_t <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointerixE9ptrdiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Index operator.  Return reference to the value stored at <code class="code docutils literal"><span class="pre">p[d]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointerppEv">
<span id="zfp::arrayANY::pointer::inc-operator"></span>pointer &amp;<code class="descclassname">pointer::</code><code class="descname">operator++</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointerppEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointermmEv">
<span id="zfp::arrayANY::pointer::dec-operator"></span>pointer &amp;<code class="descclassname">pointer::</code><code class="descname">operator--</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointermmEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pre increment (decrement) pointer, e.g., <code class="code docutils literal"><span class="pre">++p</span></code>.  Return reference to
the incremented (decremented) pointer.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointerppEi">
<span id="zfp::arrayANY::pointer::inc-operator__i"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator++</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointerppEi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointermmEi">
<span id="zfp::arrayANY::pointer::dec-operator__i"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator--</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointermmEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Post increment (decrement) pointer, e.g., <code class="code docutils literal"><span class="pre">p++</span></code>.  Return a copy of
the pointer before it was incremented (decremented).</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointerpLE9ptrdiff_t">
<span id="zfp::arrayANY::pointer::add-assign-operator__ptrdiff_t"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>ptrdiff_t <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointerpLE9ptrdiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY7pointermIE9ptrdiff_t">
<span id="zfp::arrayANY::pointer::sub-assign-operator__ptrdiff_t"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator-=</code><span class="sig-paren">(</span>ptrdiff_t <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY7pointermIE9ptrdiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment (decrement) pointer by <em>d</em>.  Return a copy of the incremented
(decremented) pointer.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointerplE9ptrdiff_t">
<span id="zfp::arrayANY::pointer::add-operator__ptrdiff_tC"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator+</code><span class="sig-paren">(</span>ptrdiff_t <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointerplE9ptrdiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointermiE9ptrdiff_t">
<span id="zfp::arrayANY::pointer::sub-operator__ptrdiff_tC"></span>pointer <code class="descclassname">pointer::</code><code class="descname">operator-</code><span class="sig-paren">(</span>ptrdiff_t <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointermiE9ptrdiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a copy of the pointer incremented (decremented) by <em>d</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointermiERK7pointer">
<span id="zfp::arrayANY::pointer::sub-operator__pointerCRC"></span>ptrdiff_t <code class="descclassname">pointer::</code><code class="descname">operator-</code><span class="sig-paren">(</span><em class="property">const</em> pointer &amp;<em>q</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointermiERK7pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return difference <em>p - q</em>.  Defined only for pointers within the same
array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointereqERK7pointer">
<span id="zfp::arrayANY::pointer::eq-operator__pointerCRC"></span>bool <code class="descclassname">pointer::</code><code class="descname">operator==</code><span class="sig-paren">(</span><em class="property">const</em> pointer &amp;<em>q</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointereqERK7pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY7pointerneERK7pointer">
<span id="zfp::arrayANY::pointer::neq-operator__pointerCRC"></span>bool <code class="descclassname">pointer::</code><code class="descname">operator!=</code><span class="sig-paren">(</span><em class="property">const</em> pointer &amp;<em>q</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY7pointerneERK7pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pointer comparison.  Return true (false) if <em>p</em> and <em>q</em> do (do not) point
to the same array element.</p>
</dd></dl>

</div>
<div class="section" id="iterators">
<span id="index-4"></span><span id="id7"></span><h2>Iterators<a class="headerlink" href="#iterators" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N3zfp6array18iteratorE">
<span id="zfp::array1::iterator"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">iterator</code><a class="headerlink" href="#_CPPv2N3zfp6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array28iteratorE">
<span id="zfp::array2::iterator"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">iterator</code><a class="headerlink" href="#_CPPv2N3zfp6array28iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array38iteratorE">
<span id="zfp::array3::iterator"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">iterator</code><a class="headerlink" href="#_CPPv2N3zfp6array38iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Iterators provide a mechanism for sequentially traversing a possibly
multi-dimensional array without having to track array indices or bounds.
They are also the preferred mechanism, compared to nested index loops, for
initializing arrays, because they are guaranteed to visit the array one block
at a time.  This allows all elements of a block to be initialized together
and ensures that the block is not compressed to memory before it has been
fully initialized, which might otherwise result in poor compression and,
consequently, larger errors than when the entire block is initialized as
a whole.  Note that the iterator traversal order differs in this respect
from traversal by <a class="reference internal" href="#pointers"><span class="std std-ref">pointers</span></a>.</p>
<p>The order of blocks visited is row-major (as in C), and the elements
within a block are also visited in row-major order, i.e., first by <em>x</em>,
then by <em>y</em>, and finally by <em>z</em>.  All 4<sup>d</sup> values in a block are visited
before moving on to the next block.</p>
<p>The iterators provided by zfp are sequential forward iterators, except
for 1D array iterators, which are random access iterators.  The reason
why higher dimensional iterators do not support random access is that
this would require very complicated index computations, especially for
arrays with partial blocks.  zfp iterators are
<a class="reference external" href="https://www.sgi.com/tech/stl/">STL</a> compliant and can
be used in STL algorithms that support forward and random access iterators.</p>
<div class="section" id="all-iterators">
<h3>All Iterators<a class="headerlink" href="#all-iterators" title="Permalink to this headline">¶</a></h3>
<p>Per STL mandate, the iterators define several types:</p>
<dl class="type">
<dt id="_CPPv2N3zfp8arrayANY8iterator10value_typeE">
<span id="zfp::arrayANY::iterator::value_type"></span><em class="property">type </em><code class="descclassname">iterator::</code><code class="descname">value_type</code><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iterator10value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The scalar type associated with the array that the iterator points into.</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv2N3zfp8arrayANY8iterator15difference_typeE">
<span id="zfp::arrayANY::iterator::difference_type"></span><em class="property">type </em><code class="descclassname">iterator::</code><code class="descname">difference_type</code><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iterator15difference_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Difference between two iterators in number of array elements.</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv2N3zfp8arrayANY8iterator9referenceE">
<span id="zfp::arrayANY::iterator::reference"></span><em class="property">type </em><code class="descclassname">iterator::</code><code class="descname">reference</code><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iterator9referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv2N3zfp8arrayANY8iterator7pointerE">
<span id="zfp::arrayANY::iterator::pointer"></span><em class="property">type </em><code class="descclassname">iterator::</code><code class="descname">pointer</code><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iterator7pointerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The reference and pointer type associated with the iterator’s parent array
class.</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv2N3zfp8arrayANY8iterator17iterator_categoryE">
<span id="zfp::arrayANY::iterator::iterator_category"></span><em class="property">type </em><code class="descclassname">iterator::</code><code class="descname">iterator_category</code><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iterator17iterator_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type of iterator: <code class="xref cpp cpp-type docutils literal"><span class="pre">std::random_access_iterator_tag</span></code> for 1D arrays;
<code class="xref cpp cpp-type docutils literal"><span class="pre">std::forward_iterator_tag</span></code> for all other arrays.</p>
</dd></dl>

<p>The following operations are defined on iterators:</p>
<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY8iteratoraSERK8iterator">
<span id="zfp::arrayANY::iterator::assign-operator__iteratorCR"></span>iterator <code class="descclassname">iterator::</code><code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> iterator &amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iteratoraSERK8iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment (copy) operator.  Make the iterator point to the same element
as <em>it</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iteratormlEv">
<span id="zfp::arrayANY::iterator::mul-operatorC"></span><a class="reference internal" href="#_CPPv2N3zfp8arrayANY8iterator9referenceE" title="zfp::arrayANY::iterator::reference">reference</a> <code class="descclassname">iterator::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iteratormlEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dereference operator.  Return reference to the value pointed to by the
iterator.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY8iteratorppEv">
<span id="zfp::arrayANY::iterator::inc-operator"></span>iterator &amp;<code class="descclassname">iterator::</code><code class="descname">operator++</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iteratorppEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pre increment.  Return a reference to the incremented iterator.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY8iteratorppEi">
<span id="zfp::arrayANY::iterator::inc-operator__i"></span>iterator <code class="descclassname">iterator::</code><code class="descname">operator++</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY8iteratorppEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Post increment.  Return the value of the iterator before being incremented.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iteratoreqERK8iterator">
<span id="zfp::arrayANY::iterator::eq-operator__iteratorCRC"></span>bool <code class="descclassname">iterator::</code><code class="descname">operator==</code><span class="sig-paren">(</span><em class="property">const</em> iterator &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iteratoreqERK8iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iteratorneERK8iterator">
<span id="zfp::arrayANY::iterator::neq-operator__iteratorCRC"></span>bool <code class="descclassname">iterator::</code><code class="descname">operator!=</code><span class="sig-paren">(</span><em class="property">const</em> iterator &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iteratorneERK8iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true (false) if the two iterators do (do not) point to the same
element.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iterator1iEv">
<span id="zfp::arrayANY::iterator::iC"></span>uint <code class="descclassname">iterator::</code><code class="descname">i</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iterator1iEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iterator1jEv">
<span id="zfp::arrayANY::iterator::jC"></span>uint <code class="descclassname">iterator::</code><code class="descname">j</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iterator1jEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY8iterator1kEv">
<span id="zfp::arrayANY::iterator::kC"></span>uint <code class="descclassname">iterator::</code><code class="descname">k</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY8iterator1kEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return array index of element pointed to by the iterator.
<a class="reference internal" href="#_CPPv2NK3zfp8arrayANY8iterator1iEv" title="zfp::arrayANY::iterator::i"><code class="xref cpp cpp-func docutils literal"><span class="pre">iterator::i()</span></code></a> is defined for all arrays.
<a class="reference internal" href="#_CPPv2NK3zfp8arrayANY8iterator1jEv" title="zfp::arrayANY::iterator::j"><code class="xref cpp cpp-func docutils literal"><span class="pre">iterator::j()</span></code></a> is defined only for 2D and 3D arrays.
<a class="reference internal" href="#_CPPv2NK3zfp8arrayANY8iterator1kEv" title="zfp::arrayANY::iterator::k"><code class="xref cpp cpp-func docutils literal"><span class="pre">iterator::k()</span></code></a> is defined only for 3D arrays.</p>
</dd></dl>

</div>
<div class="section" id="d-array-iterators">
<h3>1D Array Iterators<a class="headerlink" href="#d-array-iterators" title="Permalink to this headline">¶</a></h3>
<p>The following operators are defined <strong>only for 1D arrays</strong>:</p>
<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorixE15difference_type">
<span id="zfp::array1::iterator::subscript-operator__difference_typeC"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array19referenceE" title="zfp::array1::reference">reference</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>difference_type <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorixE15difference_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Random access index operator.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array18iteratormmEv">
<span id="zfp::array1::iterator::dec-operator"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<code class="descclassname">array1::iterator::</code><code class="descname">operator--</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array18iteratormmEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pre decrement.  Return a reference to the decremented iterator.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array18iteratormmEi">
<span id="zfp::array1::iterator::dec-operator__i"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator--</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array18iteratormmEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Post decrement.  Return the value of the iterator before being decremented.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array18iteratorpLE15difference_type">
<span id="zfp::array1::iterator::add-assign-operator__difference_type"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>difference_type <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array18iteratorpLE15difference_type" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array18iteratormIE15difference_type">
<span id="zfp::array1::iterator::sub-assign-operator__difference_type"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator-=</code><span class="sig-paren">(</span>difference_type <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array18iteratormIE15difference_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment (decrement) iterator <em>d</em> times.  Return value of incremented
(decremented) iterator.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorplE15difference_type">
<span id="zfp::array1::iterator::add-operator__difference_typeC"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator+</code><span class="sig-paren">(</span>difference_type <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorplE15difference_type" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratormiE15difference_type">
<span id="zfp::array1::iterator::sub-operator__difference_typeC"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> <code class="descclassname">array1::iterator::</code><code class="descname">operator-</code><span class="sig-paren">(</span>difference_type <em>d</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratormiE15difference_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a new iterator that has been incremented (decremented) by <em>d</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratormiERKN6array18iteratorE">
<span id="zfp::array1::iterator::sub-operator__array1::iteratorCRC"></span>difference_type <code class="descclassname">array1::iterator::</code><code class="descname">operator-</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratormiERKN6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return difference between this iterator and <em>it</em> in number of elements.
The iterators must refer to elements in the same array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorleERKN6array18iteratorE">
<span id="zfp::array1::iterator::lte-operator__array1::iteratorCRC"></span>bool <code class="descclassname">array1::iterator::</code><code class="descname">operator&lt;=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorleERKN6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorgeERKN6array18iteratorE">
<span id="zfp::array1::iterator::gte-operator__array1::iteratorCRC"></span>bool <code class="descclassname">array1::iterator::</code><code class="descname">operator&gt;=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorgeERKN6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorltERKN6array18iteratorE">
<span id="zfp::array1::iterator::lt-operator__array1::iteratorCRC"></span>bool <code class="descclassname">array1::iterator::</code><code class="descname">operator&lt;</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorltERKN6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array18iteratorgtERKN6array18iteratorE">
<span id="zfp::array1::iterator::gt-operator__array1::iteratorCRC"></span>bool <code class="descclassname">array1::iterator::</code><code class="descname">operator&gt;</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array18iteratorE" title="zfp::array1::iterator">iterator</a> &amp;<em>it</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array18iteratorgtERKN6array18iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if the two iterators satisfy the given relationship.
For two iterators, <em>p</em> and <em>q</em>, within the same array, <em>p</em> &lt; <em>q</em>
if and only if <em>q</em> can be reached by incrementing <em>p</em> one or more times.</p>
</dd></dl>

</div>
</div>
<div class="section" id="views">
<span id="index-5"></span><span id="id8"></span><h2>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h2>
<p>zfp 0.5.4 adds array views.
Much like how <a class="reference internal" href="#references"><span class="std std-ref">references</span></a> allow indirect access to
single array elements, <em>views</em> provide indirect access to whole arrays,
or more generally to rectangular subsets of arrays.  A view of an array
does not allocate any storage for the array elements.  Rather, the
view accesses shared storage managed by the underlying array.  This
allows for multiple entries into an array without the need for expensive
deep copies.  In a sense, views can be thought of as <em>shallow copies</em>
of arrays.</p>
<p>When a view exposes a whole array <code class="code docutils literal"><span class="pre">array&lt;type&gt;</span></code>, it provides
similar functionality to a C++ reference <code class="code docutils literal"><span class="pre">array&lt;type&gt;&amp;</span></code> or
pointer <code class="code docutils literal"><span class="pre">array&lt;type&gt;*</span></code> to the array.  However, views are more
general in that they also allow restricting access to a user-specified
subset of the array, and unlike pointers also provide for the same
syntax when accessing the array, e.g., <code class="code docutils literal"><span class="pre">array_view(i,</span> <span class="pre">j)</span></code> instead
of <code class="code docutils literal"><span class="pre">(*array_ptr)(i,</span> <span class="pre">j)</span></code>.</p>
<p>zfp’s <em>nested views</em> further provide for multidimensional
array access analogous to the C/C++ nested array syntax <code class="code docutils literal"><span class="pre">array[i][j]</span></code>.
Finally, zfp’s <em>private views</em> can be used to ensure thread-safe access
to its compressed arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Like iterators and proxy references and pointers, a view is valid only
during the lifetime of the array that it references.  <strong>No reference
counting</strong> is done to keep the array alive.  It is up to the user to
ensure that the referenced array object is valid when accessed through
a view.</p>
</div>
<p>There are several types of views distinguished by these attributes:</p>
<ul class="simple">
<li>Read-only vs. read-write access.</li>
<li>Shared vs. private access.</li>
<li>Flat vs. nested indexing.</li>
</ul>
<p>Each of these attributes is discussed in detail below in these
sections:</p>
<ul class="simple">
<li><a class="reference internal" href="#immutable-view"><span class="std std-ref">Immutable view</span></a></li>
<li><a class="reference internal" href="#mutable-view"><span class="std std-ref">Mutable view</span></a></li>
<li><a class="reference internal" href="#flat-view"><span class="std std-ref">Flat view</span></a></li>
<li><a class="reference internal" href="#nested-view"><span class="std std-ref">Nested view</span></a></li>
<li><a class="reference internal" href="#slicing"><span class="std std-ref">Slicing</span></a></li>
<li><a class="reference internal" href="#private-immutable-view"><span class="std std-ref">Private immutable view</span></a></li>
<li><a class="reference internal" href="#private-mutable-view"><span class="std std-ref">Private mutable view</span></a></li>
</ul>
<div class="section" id="immutable-view">
<span id="id9"></span><h3>Immutable view<a class="headerlink" href="#immutable-view" title="Permalink to this headline">¶</a></h3>
<p>The most basic view is the immutable <code class="code docutils literal"><span class="pre">const_view</span></code>, which
supports read-only access to the array elements it references.
This view serves primarily as a base class for more specialized
views.  Its constructors allow establishing access to a whole
array or to a rectangular subset of an array.  Note that like
references, pointers, and iterators, views are types nested within
the arrays that they reference.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array110const_viewE">
<span id="zfp::array1::const_view"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array110const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array210const_viewE">
<span id="zfp::array2::const_view"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array210const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array310const_viewE">
<span id="zfp::array3::const_view"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array310const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Immutable view into 1D, 2D, and 3D array.</p>
</dd></dl>

<span class="target" id="view-ctor"></span><dl class="function">
<dt id="_CPPv2N3zfp6array110const_view10const_viewEP6array1">
<span id="zfp::array1::const_view::const_view__array1P"></span><code class="descclassname">array1::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array110const_view10const_viewEP6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array210const_view10const_viewEP6array2">
<span id="zfp::array2::const_view::const_view__array2P"></span><code class="descclassname">array2::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array210const_view10const_viewEP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array310const_view10const_viewEP6array3">
<span id="zfp::array3::const_view::const_view__array3P"></span><code class="descclassname">array3::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array310const_view10const_viewEP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for read-only access to a whole array.  As already
mentioned, these views are valid only during the lifetime of the
underlying array object.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array110const_view10const_viewEP6array14uint4uint">
<span id="zfp::array1::const_view::const_view__array1P.uint.uint"></span><code class="descclassname">array1::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em>, uint <em>x</em>, uint <em>nx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array110const_view10const_viewEP6array14uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array210const_view10const_viewEP6array24uint4uint4uint4uint">
<span id="zfp::array2::const_view::const_view__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array210const_view10const_viewEP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array310const_view10const_viewEP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::const_view::const_view__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::const_view::</code><code class="descname">const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array310const_view10const_viewEP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructors for read-only access to a rectangular subset of an
array.  The subset is specified by an offset, e.g.,
(<em>x</em>, <em>y</em>, <em>z</em>) for a 3D array, and dimensions, e.g.,
(<em>nx</em>, <em>ny</em>, <em>nz</em>) for a 3D array.  The rectangle must fit within
the surrounding array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array110const_view8global_xE4uint">
<span id="zfp::array1::const_view::global_x__uintC"></span>uint <code class="descclassname">array1::const_view::</code><code class="descname">global_x</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array110const_view8global_xE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array210const_view8global_xE4uint">
<span id="zfp::array2::const_view::global_x__uintC"></span>uint <code class="descclassname">array2::const_view::</code><code class="descname">global_x</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array210const_view8global_xE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array210const_view8global_yE4uint">
<span id="zfp::array2::const_view::global_y__uintC"></span>uint <code class="descclassname">array2::const_view::</code><code class="descname">global_y</code><span class="sig-paren">(</span>uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array210const_view8global_yE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view8global_xE4uint">
<span id="zfp::array3::const_view::global_x__uintC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">global_x</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view8global_xE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view8global_yE4uint">
<span id="zfp::array3::const_view::global_y__uintC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">global_y</code><span class="sig-paren">(</span>uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view8global_yE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view8global_zE4uint">
<span id="zfp::array3::const_view::global_z__uintC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">global_z</code><span class="sig-paren">(</span>uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view8global_zE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return global array index associated with local view index.  For
instance, if a 1D view has been constructed with offset <em>x</em>, then
<code class="code docutils literal"><span class="pre">global_x(i)</span></code> returns <em>x</em> + <em>i</em>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array110const_view6size_xEv">
<span id="zfp::array1::const_view::size_xC"></span>uint <code class="descclassname">array1::const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array110const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array210const_view6size_xEv">
<span id="zfp::array2::const_view::size_xC"></span>uint <code class="descclassname">array2::const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array210const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array210const_view6size_yEv">
<span id="zfp::array2::const_view::size_yC"></span>uint <code class="descclassname">array2::const_view::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array210const_view6size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view6size_xEv">
<span id="zfp::array3::const_view::size_xC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view6size_yEv">
<span id="zfp::array3::const_view::size_yC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view6size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_view6size_zEv">
<span id="zfp::array3::const_view::size_zC"></span>uint <code class="descclassname">array3::const_view::</code><code class="descname">size_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_view6size_zEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return dimensions of view.</p>
</dd></dl>

<span class="target" id="view-accessor"></span><dl class="function">
<dt id="_CPPv2NK3zfp6array110const_viewclE4uint">
<span id="zfp::array1::const_view::call-operator__uintC"></span>Scalar <code class="descclassname">array1::const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array110const_viewclE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array210const_viewclE4uint4uint">
<span id="zfp::array2::const_view::call-operator__uint.uintC"></span>Scalar <code class="descclassname">array2::const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array210const_viewclE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array310const_viewclE4uint4uint4uint">
<span id="zfp::array3::const_view::call-operator__uint.uint.uintC"></span>Scalar <code class="descclassname">array3::const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array310const_viewclE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar stored at multi-dimensional index given by <em>x</em> + <em>i</em>,
<em>y</em> + <em>j</em>, and <em>z</em> + <em>k</em>, where <em>x</em>, <em>y</em>, and <em>z</em> specify the offset
into the array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array110const_viewixE4uint">
<span id="zfp::array1::const_view::subscript-operator__uintC"></span>Scalar <code class="descclassname">array1::const_view::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array110const_viewixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Alternative inspector for 1D arrays identical to
<a class="reference internal" href="#_CPPv2NK3zfp6array110const_viewclE4uint" title="zfp::array1::const_view::operator()"><code class="xref cpp cpp-func docutils literal"><span class="pre">array1::const_view::operator()()</span></code></a>.</p>
</dd></dl>

<p>There are a number of common methods inherited from a base class,
<code class="code docutils literal"><span class="pre">preview</span></code>, further up the class hierarchy.</p>
<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY10const_view4rateEv">
<span id="zfp::arrayANY::const_view::rateC"></span>double <code class="descclassname">arrayANY::const_view::</code><code class="descname">rate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY10const_view4rateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return rate in bits per value.  Same as <a class="reference internal" href="#_CPPv2NK3zfp5array4rateEv" title="zfp::array::rate"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::rate()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY10const_view4sizeEv">
<span id="zfp::arrayANY::const_view::sizeC"></span>size_t <code class="descclassname">arrayANY::const_view::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY10const_view4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Total number of elements in view, e.g., <em>nx</em> × <em>ny</em> × <em>nz</em> for
3D views.</p>
</dd></dl>

<p>With the above definitions, the following example shows how a 2D view is
constructed and accessed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array2d</span> <span class="n">a</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span> <span class="o">//</span> <span class="n">define</span> <span class="mi">200</span><span class="n">x100</span> <span class="n">array</span> <span class="n">of</span> <span class="n">doubles</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array2d</span><span class="p">::</span><span class="n">const_view</span> <span class="n">v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="o">//</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">a</span> <span class="mi">20</span><span class="n">x20</span> <span class="n">view</span> <span class="n">into</span> <span class="n">array</span> <span class="n">a</span>
<span class="k">assert</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span> <span class="o">//</span> <span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">400</span><span class="p">);</span> <span class="o">//</span> <span class="mi">20</span><span class="n">x20</span> <span class="o">==</span> <span class="mi">400</span>
</pre></div>
</div>
</div>
<div class="section" id="mutable-view">
<span id="id10"></span><h3>Mutable view<a class="headerlink" href="#mutable-view" title="Permalink to this headline">¶</a></h3>
<p>The basic mutable <code class="code docutils literal"><span class="pre">view</span></code> derives from the <code class="code docutils literal"><span class="pre">const_view</span></code> but
adds operators for write-access.  Its constructors are similar to those
for the <code class="code docutils literal"><span class="pre">const_view</span></code>.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array14viewE">
<span id="zfp::array1::view"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array110const_viewE" title="zfp::array1::const_view">const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array14viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array24viewE">
<span id="zfp::array2::view"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array210const_viewE" title="zfp::array2::const_view">const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array24viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array34viewE">
<span id="zfp::array3::view"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array310const_viewE" title="zfp::array3::const_view">const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array34viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mutable view into 1D, 2D, and 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array14view4viewEP6array1">
<span id="zfp::array1::view::view__array1P"></span><code class="descclassname">array1::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array14view4viewEP6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array24view4viewEP6array2">
<span id="zfp::array2::view::view__array2P"></span><code class="descclassname">array2::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array24view4viewEP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array34view4viewEP6array3">
<span id="zfp::array3::view::view__array3P"></span><code class="descclassname">array3::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array34view4viewEP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array14view4viewEP6array14uint4uint">
<span id="zfp::array1::view::view__array1P.uint.uint"></span><code class="descclassname">array1::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em>, uint <em>x</em>, uint <em>nx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array14view4viewEP6array14uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array24view4viewEP6array24uint4uint4uint4uint">
<span id="zfp::array2::view::view__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array24view4viewEP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array34view4viewEP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::view::view__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::view::</code><code class="descname">view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array34view4viewEP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whole-array and sub-array mutable view constructors.  See
<a class="reference internal" href="#view-ctor"><span class="std std-ref">const_view constructors</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array14viewclE4uint">
<span id="zfp::array1::view::call-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array19referenceE" title="zfp::array1::reference">reference</a> <code class="descclassname">array1::view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array14viewclE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array24viewclE4uint4uint">
<span id="zfp::array2::view::call-operator__uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array24viewclE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array34viewclE4uint4uint4uint">
<span id="zfp::array3::view::call-operator__uint.uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array34viewclE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These operators, whose arguments have the same meaning as in the
<a class="reference internal" href="#array-accessor"><span class="std std-ref">array accessors</span></a>, return
<a class="reference internal" href="#references"><span class="std std-ref">proxy references</span></a> to individual array elements for
write access.</p>
</dd></dl>

</div>
<div class="section" id="flat-view">
<span id="id11"></span><h3>Flat view<a class="headerlink" href="#flat-view" title="Permalink to this headline">¶</a></h3>
<p>The views discussed so far require multidimensional indexing, e.g.,
(<em>i</em>, <em>j</em>, <em>k</em>) for 3D views.  Some applications prefer one-dimensional
linear indexing, which is provided by the specialized flat view.  For
example, in a 3D view with dimensions (<em>nx</em>, <em>ny</em>, <em>nz</em>), a multidimensional
index (<em>i</em>, <em>j</em>, <em>k</em>) corresponds to the flat view index</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nx</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>This is true regardless of the view offset (<em>x</em>, <em>y</em>, <em>z</em>).</p>
<p>The flat view derives from the mutable view and adds <code class="code docutils literal"><span class="pre">operator[]</span></code>
for flat indexing.  This operator is essentially equivalent to
<a class="reference internal" href="#_CPPv2NK3zfp5arrayixE4uint" title="zfp::array::operator[]"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::operator[]()</span></code></a> defined for 2D and 3D arrays.  Flat views
also provide functions for converting between multidimensional and flat
indices.</p>
<p>Flat views are available only for 2D and 3D arrays.  The basic mutable
view, <a class="reference internal" href="#_CPPv2N3zfp6array14viewE" title="zfp::array1::view"><code class="xref cpp cpp-class docutils literal"><span class="pre">array1::view</span></code></a>, for 1D arrays can be thought of as
either a flat or a nested view.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array29flat_viewE">
<span id="zfp::array2::flat_view"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">flat_view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array24viewE" title="zfp::array2::view">view</a><a class="headerlink" href="#_CPPv2N3zfp6array29flat_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array39flat_viewE">
<span id="zfp::array3::flat_view"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">flat_view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array24viewE" title="zfp::array2::view">view</a><a class="headerlink" href="#_CPPv2N3zfp6array39flat_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flat, mutable views for 2D and 3D arrays.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array29flat_view9flat_viewEP6array2">
<span id="zfp::array2::flat_view::flat_view__array2P"></span><code class="descclassname">array2::flat_view::</code><code class="descname">flat_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array29flat_view9flat_viewEP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array39flat_view9flat_viewEP6array3">
<span id="zfp::array3::flat_view::flat_view__array3P"></span><code class="descclassname">array3::flat_view::</code><code class="descname">flat_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array39flat_view9flat_viewEP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array29flat_view9flat_viewEP6array24uint4uint4uint4uint">
<span id="zfp::array2::flat_view::flat_view__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::flat_view::</code><code class="descname">flat_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array29flat_view9flat_viewEP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array39flat_view9flat_viewEP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::flat_view::flat_view__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::flat_view::</code><code class="descname">flat_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array39flat_view9flat_viewEP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whole-array and sub-array flat view constructors.  See
<a class="reference internal" href="#view-ctor"><span class="std std-ref">const_view constructors</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array29flat_view5indexE4uint4uint">
<span id="zfp::array2::flat_view::index__uint.uintC"></span>uint <code class="descclassname">array2::flat_view::</code><code class="descname">index</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array29flat_view5indexE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array39flat_view5indexE4uint4uint4uint">
<span id="zfp::array3::flat_view::index__uint.uint.uintC"></span>uint <code class="descclassname">array3::flat_view::</code><code class="descname">index</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array39flat_view5indexE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return flat index associated with multidimensional index.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array29flat_view2ijER4uintR4uint4uint">
<span id="zfp::array2::flat_view::ij__uintR.uintR.uintC"></span>void <code class="descclassname">array2::flat_view::</code><code class="descname">ij</code><span class="sig-paren">(</span>uint &amp;<em>i</em>, uint &amp;<em>j</em>, uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array29flat_view2ijER4uintR4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array39flat_view3ijkER4uintR4uintR4uint4uint">
<span id="zfp::array3::flat_view::ijk__uintR.uintR.uintR.uintC"></span>void <code class="descclassname">array3::flat_view::</code><code class="descname">ijk</code><span class="sig-paren">(</span>uint &amp;<em>i</em>, uint &amp;<em>j</em>, uint &amp;<em>k</em>, uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array39flat_view3ijkER4uintR4uintR4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert flat index to multidimensional index.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array29flat_viewixE4uint">
<span id="zfp::array2::flat_view::subscript-operator__uintC"></span>Scalar <code class="descclassname">array2::flat_view::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array29flat_viewixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array39flat_viewixE4uint">
<span id="zfp::array3::flat_view::subscript-operator__uintC"></span>Scalar <code class="descclassname">array3::flat_view::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array39flat_viewixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return array element associated with given flat index.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array29flat_viewixE4uint">
<span id="zfp::array2::flat_view::subscript-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::flat_view::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array29flat_viewixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array39flat_viewixE4uint">
<span id="zfp::array3::flat_view::subscript-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::flat_view::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array39flat_viewixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return reference to array element associated with given flat index.</p>
</dd></dl>

</div>
<div class="section" id="nested-view">
<span id="id12"></span><h3>Nested view<a class="headerlink" href="#nested-view" title="Permalink to this headline">¶</a></h3>
<p>C and C++ support nested arrays (arrays of arrays), e.g.,
<code class="code docutils literal"><span class="pre">double</span> <span class="pre">a[10][20][30]</span></code>, which are usually accessed via nested indexing
<code class="code docutils literal"><span class="pre">a[i][j][k]</span></code>.  Here <code class="code docutils literal"><span class="pre">a</span></code> is a 3D array, <code class="code docutils literal"><span class="pre">a[i]</span></code> is a 2D array,
and <code class="code docutils literal"><span class="pre">a[i][j]</span></code> is a 1D array.  This 3D array can also be accessed
via flat indexing, e.g.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">600</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<p>Nested views provide a mechanism to access array elements through
nested indexing and to extract lower-dimensional “slices” of
multidimensional arrays.  Nested views are mutable.</p>
<p>Nested views are associated with a dimensionality.  For instance,
if <code class="code docutils literal"><span class="pre">v</span></code> is a 3D nested view of a 3D array, then <code class="code docutils literal"><span class="pre">v[i]</span></code>
is a 2D nested view (of a 3D array), <code class="code docutils literal"><span class="pre">v[i][j]</span></code> is a 1D nested
view (of a 3D array), and <code class="code docutils literal"><span class="pre">v[i][j][k]</span></code> is a scalar array element.
Note that the order of indices is reversed when using nested indexing
compared to multidimensional indexing, e.g.,
<code class="code docutils literal"><span class="pre">v(i,</span> <span class="pre">j,</span> <span class="pre">k)</span> <span class="pre">==</span> <span class="pre">v[k][j][i]</span></code>.</p>
<p>Whereas <code class="code docutils literal"><span class="pre">operator[]</span></code> on an array object accesses an element
through flat indexing, the same array can be accessed through a
nested view to in effect provide nested array indexing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">a</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span> <span class="o">//</span> <span class="n">define</span> <span class="mi">30</span><span class="n">x20x10</span> <span class="mi">3</span><span class="n">D</span> <span class="n">array</span>
<span class="k">assert</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="o">//</span> <span class="n">OK</span><span class="p">:</span> <span class="n">flat</span> <span class="ow">and</span> <span class="n">multidimensional</span> <span class="n">indexing</span>
<span class="k">assert</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span> <span class="o">//</span> <span class="n">ERROR</span><span class="p">:</span> <span class="n">a</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">support</span> <span class="n">nested</span> <span class="n">indexing</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="p">::</span><span class="n">nested_view</span> <span class="n">v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">define</span> <span class="n">a</span> <span class="n">nested</span> <span class="n">view</span> <span class="n">of</span> <span class="n">a</span>
<span class="k">assert</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span> <span class="o">//</span> <span class="n">OK</span><span class="p">:</span> <span class="n">v</span> <span class="n">supports</span> <span class="n">nested</span> <span class="n">indexing</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array2d</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span> <span class="o">//</span> <span class="n">define</span> <span class="ow">and</span> <span class="n">deep</span> <span class="n">copy</span> <span class="mi">30</span><span class="n">x20</span> <span class="mi">2</span><span class="n">D</span> <span class="nb">slice</span> <span class="n">of</span> <span class="n">a</span>
<span class="k">assert</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="o">//</span> <span class="n">OK</span><span class="p">:</span> <span class="n">multidimensional</span> <span class="n">indexing</span>
</pre></div>
</div>
<dl class="class">
<dt id="_CPPv2N3zfp6array212nested_view1E">
<span id="zfp::array2::nested_view1"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">nested_view1</code><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View of a 1D slice of a 2D array.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array212nested_view2E">
<span id="zfp::array2::nested_view2"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">nested_view2</code><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2D view of a 2D (sub)array.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array312nested_view1E">
<span id="zfp::array3::nested_view1"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">nested_view1</code><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View of a 1D slice of a 3D array.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array312nested_view2E">
<span id="zfp::array3::nested_view2"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">nested_view2</code><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View of a 2D slice of a 3D array.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array312nested_view3E">
<span id="zfp::array3::nested_view3"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">nested_view3</code><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view3E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>3D view of a 3D (sub)array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212nested_view212nested_view2EP6array2">
<span id="zfp::array2::nested_view2::nested_view2__array2P"></span><code class="descclassname">array2::nested_view2::</code><code class="descname">nested_view2</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view212nested_view2EP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view312nested_view3EP6array3">
<span id="zfp::array3::nested_view3::nested_view3__array3P"></span><code class="descclassname">array3::nested_view3::</code><code class="descname">nested_view3</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view312nested_view3EP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212nested_view212nested_view2EP6array24uint4uint4uint4uint">
<span id="zfp::array2::nested_view2::nested_view2__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::nested_view2::</code><code class="descname">nested_view2</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view212nested_view2EP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view312nested_view3EP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::nested_view3::nested_view3__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::nested_view3::</code><code class="descname">nested_view3</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view312nested_view3EP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whole-array and sub-array nested view constructors.  See
<a class="reference internal" href="#immutable-view"><span class="std std-ref">const_view</span></a> constructors for details.
Lower-dimensional view constructors are not accessible to the
user but are invoked when accessing views via nested indexing.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view16size_xEv">
<span id="zfp::array2::nested_view1::size_xC"></span><code class="descclassname">array2::nested_view1::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view16size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view26size_xEv">
<span id="zfp::array2::nested_view2::size_xC"></span><code class="descclassname">array2::nested_view2::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view26size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view26size_yEv">
<span id="zfp::array2::nested_view2::size_yC"></span><code class="descclassname">array2::nested_view2::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view26size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view16size_xEv">
<span id="zfp::array3::nested_view1::size_xC"></span><code class="descclassname">array3::nested_view1::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view16size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view26size_xEv">
<span id="zfp::array3::nested_view2::size_xC"></span><code class="descclassname">array3::nested_view2::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view26size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view26size_yEv">
<span id="zfp::array3::nested_view2::size_yC"></span><code class="descclassname">array3::nested_view2::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view26size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view36size_xEv">
<span id="zfp::array3::nested_view3::size_xC"></span><code class="descclassname">array3::nested_view3::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view36size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view36size_yEv">
<span id="zfp::array3::nested_view3::size_yC"></span><code class="descclassname">array3::nested_view3::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view36size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view36size_zEv">
<span id="zfp::array3::nested_view3::size_zC"></span><code class="descclassname">array3::nested_view3::</code><code class="descname">size_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view36size_zEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view3ixE4uint">
<span id="zfp::array3::nested_view3::subscript-operator__uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array312nested_view2E" title="zfp::array3::nested_view2">nested_view2</a> <code class="descclassname">array3::nested_view3::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view3ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return view to a 2D slice of a 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view2ixE4uint">
<span id="zfp::array2::nested_view2::subscript-operator__uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array212nested_view1E" title="zfp::array2::nested_view1">nested_view1</a> <code class="descclassname">array2::nested_view2::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view2ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view2ixE4uint">
<span id="zfp::array3::nested_view2::subscript-operator__uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array312nested_view1E" title="zfp::array3::nested_view1">nested_view1</a> <code class="descclassname">array3::nested_view2::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view2ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return view to a 1D slice of a 2D or 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view1ixE4uint">
<span id="zfp::array2::nested_view1::subscript-operator__uintC"></span>Scalar <code class="descclassname">array2::nested_view1::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view1ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view1ixE4uint">
<span id="zfp::array3::nested_view1::subscript-operator__uintC"></span>Scalar <code class="descclassname">array3::nested_view1::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view1ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar element of a 2D or 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212nested_view1ixE4uint">
<span id="zfp::array2::nested_view1::subscript-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::nested_view1::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view1ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view1ixE4uint">
<span id="zfp::array3::nested_view1::subscript-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::nested_view1::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view1ixE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return reference to a scalar element of a 2D or 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view1clE4uint">
<span id="zfp::array2::nested_view1::call-operator__uintC"></span>Scalar <code class="descclassname">array2::nested_view1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212nested_view2clE4uint4uint">
<span id="zfp::array2::nested_view2::call-operator__uint.uintC"></span>Scalar <code class="descclassname">array2::nested_view2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212nested_view2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view1clE4uint">
<span id="zfp::array3::nested_view1::call-operator__uintC"></span>Scalar <code class="descclassname">array3::nested_view1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view2clE4uint4uint">
<span id="zfp::array3::nested_view2::call-operator__uint.uintC"></span>Scalar <code class="descclassname">array3::nested_view2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312nested_view3clE4uint4uint4uint">
<span id="zfp::array3::nested_view3::call-operator__uint.uint.uintC"></span>Scalar <code class="descclassname">array3::nested_view3::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312nested_view3clE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar element of a 2D or 3D array.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212nested_view1clE4uint">
<span id="zfp::array2::nested_view1::call-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::nested_view1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212nested_view2clE4uint4uint">
<span id="zfp::array2::nested_view2::call-operator__uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array29referenceE" title="zfp::array2::reference">reference</a> <code class="descclassname">array2::nested_view2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212nested_view2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view1clE4uint">
<span id="zfp::array3::nested_view1::call-operator__uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::nested_view1::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view1clE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view2clE4uint4uint">
<span id="zfp::array3::nested_view2::call-operator__uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::nested_view2::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view2clE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312nested_view3clE4uint4uint4uint">
<span id="zfp::array3::nested_view3::call-operator__uint.uint.uint"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array39referenceE" title="zfp::array3::reference">reference</a> <code class="descclassname">array3::nested_view3::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312nested_view3clE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return reference to a scalar element of a 2D or 3D array.</p>
</dd></dl>

</div>
<div class="section" id="slicing">
<span id="id13"></span><h3>Slicing<a class="headerlink" href="#slicing" title="Permalink to this headline">¶</a></h3>
<p>Arrays can be constructed as deep copies of slices of higher-dimensional
arrays, as the code example above shows (i.e.,
<code class="code docutils literal"><span class="pre">zfp::array2d</span> <span class="pre">b(v[5]);</span></code>).  Unlike views, which have reference
semantics, such array <em>slicing</em> has value semantics.  In this example,
2D array <em>b</em> is initialized as a (deep) copy of a slice of 3D array <em>a</em>
via nested view <em>v</em>.  Subsequent modifications of <em>b</em> have no effect on
<em>a</em>.</p>
<p>Slicing is implemented as array constructors templated on views.
Upon initialization, elements are copied one at a time from the view
via multidimensional indexing, e.g., <code class="code docutils literal"><span class="pre">v(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code>.  Note that
view and array dimensionalities must match, but aside from this an
array may be constructed from any view.</p>
<p>Slicing needs not change the dimensionality, but can be used to copy
an equidimensional subset of one array to another array, as in this
example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">a</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span><span class="p">::</span><span class="n">const_view</span> <span class="n">v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">b</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="k">assert</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size_x</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size_y</span><span class="p">()</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size_z</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span><span class="p">);</span>
</pre></div>
</div>
<p>Slicing adds the following templated array constructors.</p>
<dl class="function">
<dt id="_CPPv2I0EN3zfp6array16array1ERK4View">
template&lt;class <code class="descname">View</code>&gt;<br /><code class="descclassname">array1::</code><code class="descname">array1</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN3zfp6array16array1ERK4View" title="zfp::array1::array1::View">View</a> &amp;<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN3zfp6array16array1ERK4View" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2I0EN3zfp6array26array2ERK4View">
template&lt;class <code class="descname">View</code>&gt;<br /><code class="descclassname">array2::</code><code class="descname">array2</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN3zfp6array26array2ERK4View" title="zfp::array2::array2::View">View</a> &amp;<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN3zfp6array26array2ERK4View" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2I0EN3zfp6array36array3ERK4View">
template&lt;class <code class="descname">View</code>&gt;<br /><code class="descclassname">array3::</code><code class="descname">array3</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2I0EN3zfp6array36array3ERK4View" title="zfp::array3::array3::View">View</a> &amp;<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2I0EN3zfp6array36array3ERK4View" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct array from a view via a deep copy.  The view, <em>v</em>, must support
<a class="reference internal" href="#view-accessor"><span class="std std-ref">multidimensional indexing</span></a>.
The rate for the constructed array is initialized to the rate of the array
associated with the view.  Note that the actual rate may differ if the
constructed array is a lower-dimensional slice of a higher-dimensional
array due to lower rate granularity (see FAQ <a class="reference internal" href="faq.html#q-granularity"><span class="std std-ref">#12</span></a>).
The cache size of the constructed array is set to the default size.</p>
</dd></dl>

</div>
<div class="section" id="private-immutable-view">
<span id="id14"></span><h3>Private immutable view<a class="headerlink" href="#private-immutable-view" title="Permalink to this headline">¶</a></h3>
<p>zfp’s compressed arrays are in general not thread-safe.  The main
reason for this is that each array maintains its own cache of
uncompressed blocks.  Race conditions on the cache would occur unless
it were locked upon each and every array access, which would have a
prohibitive performance cost.</p>
<p>To ensure thread-safe access, zfp provides private mutable and
immutable views of arrays that maintain their own private caches.
The <code class="code docutils literal"><span class="pre">private_const_view</span></code> immutable view provides read-only
access to the underlying array.  It is similar to a
<a class="reference internal" href="#immutable-view"><span class="std std-ref">const_view</span></a> in this sense, but differs in
that it maintains its own private cache rather than sharing the
cache owned by the array.  Multiple threads may thus access the
same array in parallel through their own private views.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Private views <strong>do not guarantee cache coherence</strong>.  If, for example,
the array is modified, then already cached data in a private view is
not automatically updated.  It is up to the user to ensure cache
coherence by flushing (compressing modified blocks) or clearing
(emptying) caches when appropriate.</p>
</div>
<p>The cache associated with a private view can be manipulated in the
same way an array’s cache can.  For instance, the user may set the
cache size on a per-view basis.</p>
<p>Unlike with <a class="reference internal" href="#private-mutable-view"><span class="std std-ref">private mutable views</span></a>,
private immutable views may freely access any element in the
array visible through the view, i.e., multiple threads may
read the same array element simultaneously.  For an example of how
to use private views for both read and write multithreaded access,
see the <a class="reference internal" href="examples.html#ex-diffusion"><span class="std std-ref">diffusion</span></a> code example.</p>
<p>Private views support only multidimensional indexing, i.e., they
are neither flat nor nested.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array118private_const_viewE">
<span id="zfp::array1::private_const_view"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">private_const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array118private_const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array218private_const_viewE">
<span id="zfp::array2::private_const_view"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">private_const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array218private_const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array318private_const_viewE">
<span id="zfp::array3::private_const_view"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">private_const_view</code><a class="headerlink" href="#_CPPv2N3zfp6array318private_const_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Immutable views of 1D, 2D, and 3D arrays with private caches.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array118private_const_view18private_const_viewEP6array1">
<span id="zfp::array1::private_const_view::private_const_view__array1P"></span><code class="descclassname">array1::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array118private_const_view18private_const_viewEP6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array218private_const_view18private_const_viewEP6array2">
<span id="zfp::array2::private_const_view::private_const_view__array2P"></span><code class="descclassname">array2::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array218private_const_view18private_const_viewEP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array318private_const_view18private_const_viewEP6array3">
<span id="zfp::array3::private_const_view::private_const_view__array3P"></span><code class="descclassname">array3::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array318private_const_view18private_const_viewEP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array118private_const_view18private_const_viewEP6array14uint4uint">
<span id="zfp::array1::private_const_view::private_const_view__array1P.uint.uint"></span><code class="descclassname">array1::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em>, uint <em>x</em>, uint <em>nx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array118private_const_view18private_const_viewEP6array14uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array218private_const_view18private_const_viewEP6array24uint4uint4uint4uint">
<span id="zfp::array2::private_const_view::private_const_view__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array218private_const_view18private_const_viewEP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array318private_const_view18private_const_viewEP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::private_const_view::private_const_view__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::private_const_view::</code><code class="descname">private_const_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array318private_const_view18private_const_viewEP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whole-array and sub-array private immutable view constructors.  See
<a class="reference internal" href="#view-ctor"><span class="std std-ref">const_view constructors</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array118private_const_view6size_xEv">
<span id="zfp::array1::private_const_view::size_xC"></span><code class="descclassname">array1::private_const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array118private_const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array218private_const_view6size_xEv">
<span id="zfp::array2::private_const_view::size_xC"></span><code class="descclassname">array2::private_const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array218private_const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array218private_const_view6size_yEv">
<span id="zfp::array2::private_const_view::size_yC"></span><code class="descclassname">array2::private_const_view::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array218private_const_view6size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array318private_const_view6size_xEv">
<span id="zfp::array3::private_const_view::size_xC"></span><code class="descclassname">array3::private_const_view::</code><code class="descname">size_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array318private_const_view6size_xEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array318private_const_view6size_yEv">
<span id="zfp::array3::private_const_view::size_yC"></span><code class="descclassname">array3::private_const_view::</code><code class="descname">size_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array318private_const_view6size_yEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array318private_const_view6size_zEv">
<span id="zfp::array3::private_const_view::size_zC"></span><code class="descclassname">array3::private_const_view::</code><code class="descname">size_z</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array318private_const_view6size_zEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array118private_const_viewclE4uint">
<span id="zfp::array1::private_const_view::call-operator__uintC"></span>Scalar <code class="descclassname">array1::private_const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array118private_const_viewclE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array218private_const_viewclE4uint4uint">
<span id="zfp::array2::private_const_view::call-operator__uint.uintC"></span>Scalar <code class="descclassname">array2::private_const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array218private_const_viewclE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array318private_const_viewclE4uint4uint4uint">
<span id="zfp::array3::private_const_view::call-operator__uint.uint.uintC"></span>Scalar <code class="descclassname">array3::private_const_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array318private_const_viewclE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return scalar element of a 1D, 2D, or 3D array.</p>
</dd></dl>

<p>The following functions are common among all dimensionalities:</p>
<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY18private_const_view10cache_sizeEv">
<span id="zfp::arrayANY::private_const_view::cache_sizeC"></span>size_t <code class="descclassname">arrayANY::private_const_view::</code><code class="descname">cache_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY18private_const_view10cache_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY18private_const_view14set_cache_sizeE6size_t">
<span id="zfp::arrayANY::private_const_view::set_cache_size__s"></span>void <code class="descclassname">arrayANY::private_const_view::</code><code class="descname">set_cache_size</code><span class="sig-paren">(</span>size_t <em>csize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY18private_const_view14set_cache_sizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY18private_const_view11clear_cacheEv">
<span id="zfp::arrayANY::private_const_view::clear_cacheC"></span>void <code class="descclassname">arrayANY::private_const_view::</code><code class="descname">clear_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY18private_const_view11clear_cacheEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cache manipulation.  See <a class="reference internal" href="#caching"><span class="std std-ref">Caching</span></a> for details.</p>
</dd></dl>

</div>
<div class="section" id="private-mutable-view">
<span id="id15"></span><h3>Private mutable view<a class="headerlink" href="#private-mutable-view" title="Permalink to this headline">¶</a></h3>
<p>The mutable <code class="code docutils literal"><span class="pre">private_view</span></code> supports both read and write access
and is backed by a private cache.  Because block compression, as needed
to support write access, is not an atomic operation, mutable views
and multithreading imply potential race conditions on the compressed
blocks stored by an array.  Although locking the array or individual
blocks upon compression would be a potential solution, this would either
serialize compression, thus hurting performance, or add a possibly large
memory overhead by maintaining a lock with each block.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid multiple threads simultaneously compressing the same block,
<strong>private mutable views of an array must reference disjoint,
block-aligned subarrays</strong> for thread-safe access.  Each block of 4<sup>d</sup>
array elements must be associated with at most one private mutable view,
and therefore these views must reference non-overlapping rectangular
subsets that are aligned on block boundaries, except possibly for partial
blocks on the array boundary.  (Expert users may alternatively ensure
serialization of block compression calls and cache coherence in other
ways, in which case overlapping private views may be permitted.)</p>
</div>
<p>Aside from this requirement, the user may partition the array into
disjoint views in whatever manner is suitable for the application.
The <code class="code docutils literal"><span class="pre">private_view</span></code> API supplies a very basic partitioner to
facilitate this task, but may not result in optimal partitions or
good load balance.</p>
<p>When multithreaded write access is desired, any direct accesses to the
array itself (i.e., not through a view) could invoke compression.  Even
a read access may trigger compression if a modified block is evicted
from the cache.  Hence, such direct array accesses should be confined
to serial code sections when private views are used.</p>
<p>As with private immutable views, <strong>cache coherence is not enforced</strong>.
Although this is less of an issue for private mutable views due to
the requirement that views may not overlap, each private mutable view
overlaps an index space with the underlying array whose cache is not
automatically synchronized with the view’s private cache.  See
the <a class="reference internal" href="examples.html#ex-diffusion"><span class="std std-ref">diffusion</span></a> for an example of how to enforce
cache coherence with mutable and immutable private views.</p>
<p>The <code class="code docutils literal"><span class="pre">private_view</span></code> class inherits all public functions from
<code class="code docutils literal"><span class="pre">private_const_view</span></code>.</p>
<dl class="class">
<dt id="_CPPv2N3zfp6array112private_viewE">
<span id="zfp::array1::private_view"></span><em class="property">class </em><code class="descclassname">array1::</code><code class="descname">private_view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array118private_const_viewE" title="zfp::array1::private_const_view">private_const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array112private_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array212private_viewE">
<span id="zfp::array2::private_view"></span><em class="property">class </em><code class="descclassname">array2::</code><code class="descname">private_view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array218private_const_viewE" title="zfp::array2::private_const_view">private_const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array212private_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array312private_viewE">
<span id="zfp::array3::private_view"></span><em class="property">class </em><code class="descclassname">array3::</code><code class="descname">private_view</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array318private_const_viewE" title="zfp::array3::private_const_view">private_const_view</a><a class="headerlink" href="#_CPPv2N3zfp6array312private_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mutable views of 1D, 2D, and 3D arrays with private caches.</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array112private_view14view_referenceE">
<span id="zfp::array1::private_view::view_reference"></span><em class="property">class </em><code class="descclassname">array1::private_view::</code><code class="descname">view_reference</code><a class="headerlink" href="#_CPPv2N3zfp6array112private_view14view_referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array212private_view14view_referenceE">
<span id="zfp::array2::private_view::view_reference"></span><em class="property">class </em><code class="descclassname">array2::private_view::</code><code class="descname">view_reference</code><a class="headerlink" href="#_CPPv2N3zfp6array212private_view14view_referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv2N3zfp6array312private_view14view_referenceE">
<span id="zfp::array3::private_view::view_reference"></span><em class="property">class </em><code class="descclassname">array3::private_view::</code><code class="descname">view_reference</code><a class="headerlink" href="#_CPPv2N3zfp6array312private_view14view_referenceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Proxy references to array elements specialized for mutable
private views.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array112private_view12private_viewEP6array1">
<span id="zfp::array1::private_view::private_view__array1P"></span><code class="descclassname">array1::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array112private_view12private_viewEP6array1" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212private_view12private_viewEP6array2">
<span id="zfp::array2::private_view::private_view__array2P"></span><code class="descclassname">array2::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212private_view12private_viewEP6array2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312private_view12private_viewEP6array3">
<span id="zfp::array3::private_view::private_view__array3P"></span><code class="descclassname">array3::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312private_view12private_viewEP6array3" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array112private_view12private_viewEP6array14uint4uint">
<span id="zfp::array1::private_view::private_view__array1P.uint.uint"></span><code class="descclassname">array1::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a> *<em>array</em>, uint <em>x</em>, uint <em>nx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array112private_view12private_viewEP6array14uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array212private_view12private_viewEP6array24uint4uint4uint4uint">
<span id="zfp::array2::private_view::private_view__array2P.uint.uint.uint.uint"></span><code class="descclassname">array2::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>nx</em>, uint <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array212private_view12private_viewEP6array24uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2N3zfp6array312private_view12private_viewEP6array34uint4uint4uint4uint4uint4uint">
<span id="zfp::array3::private_view::private_view__array3P.uint.uint.uint.uint.uint.uint"></span><code class="descclassname">array3::private_view::</code><code class="descname">private_view</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a> *<em>array</em>, uint <em>x</em>, uint <em>y</em>, uint <em>z</em>, uint <em>nx</em>, uint <em>ny</em>, uint <em>nz</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp6array312private_view12private_viewEP6array34uint4uint4uint4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whole-array and sub-array private mutable view constructors.  See
<a class="reference internal" href="#view-ctor"><span class="std std-ref">const_view constructors</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array112private_viewclE4uint">
<span id="zfp::array1::private_view::call-operator__uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array1E" title="zfp::array1">array1</a>::<a class="reference internal" href="#_CPPv2N3zfp6array112private_viewE" title="zfp::array1::private_view">private_view</a>::<a class="reference internal" href="#_CPPv2N3zfp6array112private_view14view_referenceE" title="zfp::array1::private_view::view_reference">view_reference</a> <code class="descclassname">array1::private_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array112private_viewclE4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array212private_viewclE4uint4uint">
<span id="zfp::array2::private_view::call-operator__uint.uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array2E" title="zfp::array2">array2</a>::<a class="reference internal" href="#_CPPv2N3zfp6array212private_viewE" title="zfp::array2::private_view">private_view</a>::<a class="reference internal" href="#_CPPv2N3zfp6array212private_view14view_referenceE" title="zfp::array2::private_view::view_reference">view_reference</a> <code class="descclassname">array2::private_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array212private_viewclE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp6array312private_viewclE4uint4uint4uint">
<span id="zfp::array3::private_view::call-operator__uint.uint.uintC"></span><a class="reference internal" href="#_CPPv2N3zfp6array3E" title="zfp::array3">array3</a>::<a class="reference internal" href="#_CPPv2N3zfp6array312private_viewE" title="zfp::array3::private_view">private_view</a>::<a class="reference internal" href="#_CPPv2N3zfp6array312private_view14view_referenceE" title="zfp::array3::private_view::view_reference">view_reference</a> <code class="descclassname">array3::private_view::</code><code class="descname">operator()</code><span class="sig-paren">(</span>uint <em>i</em>, uint <em>j</em>, uint <em>k</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp6array312private_viewclE4uint4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return reference to a scalar element of a 1D, 2D, or 3D array.</p>
</dd></dl>

<p>The following functions are common among all dimensionalities:</p>
<dl class="function">
<dt id="_CPPv2N3zfp8arrayANY12private_view9partitionE4uint4uint">
<span id="zfp::arrayANY::private_view::partition__uint.uint"></span>void <code class="descclassname">arrayANY::private_view::</code><code class="descname">partition</code><span class="sig-paren">(</span>uint <em>index</em>, uint <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N3zfp8arrayANY12private_view9partitionE4uint4uint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Partition the current view into <em>count</em> roughly equal-size pieces along the
view’s longest dimension and modify the view’s extents to match the piece
indexed by <em>index</em>, with 0 ≤ <em>index</em> &lt; <em>count</em>.
These functions may be called multiple times, e.g., to recursively
partition along different dimensions.  The partitioner does not generate
new views; it merely modifies the current values of the view’s offsets
and dimensions.  Note that this may result in empty views whose dimensions
are zero, e.g., if there are more pieces than blocks along a dimension.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK3zfp8arrayANY12private_view11flush_cacheEv">
<span id="zfp::arrayANY::private_view::flush_cacheC"></span>void <code class="descclassname">arrayANY::private_view::</code><code class="descname">flush_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK3zfp8arrayANY12private_view11flush_cacheEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush cache by compressing any modified blocks and emptying the cache.</p>
</dd></dl>

</div>
</div>
<div class="section" id="c-bindings">
<span id="cfp"></span><span id="index-6"></span><h2>C bindings<a class="headerlink" href="#c-bindings" title="Permalink to this headline">¶</a></h2>
<p>zfp 0.5.4 adds cfp: C language bindings for compressed arrays
via wrappers around the C++ classes.</p>
<p>The C API has been designed to facilitate working with compressed arrays
without the benefits of C++ operator overloading and self-aware objects,
which greatly simplify the syntax.  Whereas one possible design considered
is to map each C++ method to a C function with a prefix, such as
<code class="code docutils literal"><span class="pre">zfp_array3d_get(a,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code> in place of <code class="code docutils literal"><span class="pre">a(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code> for
accessing an element of a 3D array of doubles, such code would quickly
become unwieldy when part of longer expressions.</p>
<p>Instead, cfp uses the notion of nested C <em>namespaces</em> that are structs
of function pointers, such as <code class="code docutils literal"><span class="pre">cfp.array3d</span></code>.  Although this may
seem no more concise than a design based on prefixes, the user may alias
these namespaces (somewhat similar to C++ <code class="code docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></code>
declarations) using far shorter names via C macros or local variables.
For instance:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">cfp_array3d_api</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cfp</span><span class="o">.</span><span class="n">array3d</span><span class="p">;</span> <span class="o">//</span> <span class="n">_</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">namespace</span> <span class="n">alias</span>
<span class="n">cfp_array3d</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">ctor</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
<span class="n">_</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>which is a substitute for the C++ code</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">zfp</span><span class="p">::</span><span class="n">array3d</span> <span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
<span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Because the underlying C++ objects have no corresponding C representation,
and because C objects are not self aware (they have no implicit <code class="code docutils literal"><span class="pre">this</span></code>
pointer), the C interface interacts with compressed arrays through
<em>pointers</em> to opaque types that cfp converts to pointers to
the corresponding C++ objects.  As a consequence, cfp compressed arrays
must be allocated on the heap and explicitly freed via designated
destructor functions to avoid memory leaks.  The C++ constructors
are mapped to C by allocating objects via C++ <code class="code docutils literal"><span class="pre">new</span></code>.  Moreover, the
C API requires passing an array <em>self pointer</em> in order to manipulate the
array.</p>
<p>As with the <a class="reference internal" href="#array-classes"><span class="std std-ref">C++ classes</span></a>, array elements can be
accessed via multidimensional array indexing, e.g., <code class="code docutils literal"><span class="pre">get(array,</span> <span class="pre">i,</span> <span class="pre">j)</span></code>,
and via flat, linear indexing, e.g., <code class="code docutils literal"><span class="pre">get_flat(array,</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">nx</span> <span class="pre">*</span> <span class="pre">j)</span></code>.</p>
<dl class="type">
<dt id="c.cfp_array1f">
<code class="descname">cfp_array1f</code><a class="headerlink" href="#c.cfp_array1f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.cfp_array2f">
<code class="descname">cfp_array2f</code><a class="headerlink" href="#c.cfp_array2f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.cfp_array3f">
<code class="descname">cfp_array3f</code><a class="headerlink" href="#c.cfp_array3f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.cfp_array1d">
<code class="descname">cfp_array1d</code><a class="headerlink" href="#c.cfp_array1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.cfp_array2d">
<code class="descname">cfp_array2d</code><a class="headerlink" href="#c.cfp_array2d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.cfp_array3d">
<code class="descname">cfp_array3d</code><a class="headerlink" href="#c.cfp_array3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Opaque types for 1D, 2D, and 3D compressed arrays of floats and doubles.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array1f.ctor">
<a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>* <code class="descname">cfp_array1f.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, double<em>&nbsp;rate</em>, const float*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.ctor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.ctor">
<a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>* <code class="descname">cfp_array1d.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, double<em>&nbsp;rate</em>, const double*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.ctor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.ctor">
<a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>* <code class="descname">cfp_array2f.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, double<em>&nbsp;rate</em>, const float*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.ctor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.ctor">
<a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>* <code class="descname">cfp_array2d.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, double<em>&nbsp;rate</em>, const double*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.ctor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.ctor">
<a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>* <code class="descname">cfp_array3f.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, uint<em>&nbsp;nz</em>, double<em>&nbsp;rate</em>, const float*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.ctor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.ctor">
<a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>* <code class="descname">cfp_array3d.ctor</code><span class="sig-paren">(</span>uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, uint<em>&nbsp;nz</em>, double<em>&nbsp;rate</em>, const double*<em>&nbsp;p</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.ctor" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#array-ctor"><span class="std std-ref">Array constructors</span></a>.
If <em>p</em> is not <code class="code docutils literal"><span class="pre">NULL</span></code>, then the array is initialized from uncompressed
storage; otherwise the array is zero initialized.  <em>csize</em> is the minimum
size cache (in bytes) to use.  If <em>csize</em> is zero, a default size is chosen.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array1f.get">
float <code class="descname">cfp_array1f.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.get">
float <code class="descname">cfp_array2f.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.get">
float <code class="descname">cfp_array3f.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, uint<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.get">
double <code class="descname">cfp_array1d.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1d" title="cfp_array1d">cfp_array1d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.get">
double <code class="descname">cfp_array2d.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.get">
double <code class="descname">cfp_array3d.get</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, uint<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.get" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#array-accessor"><span class="std std-ref">Array accessors</span></a> via multidimensional indexing.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array1f.set">
void <code class="descname">cfp_array1f.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, float<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.set">
void <code class="descname">cfp_array2f.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, float<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.set">
void <code class="descname">cfp_array3f.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, uint<em>&nbsp;k</em>, float<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.set">
void <code class="descname">cfp_array1d.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1d" title="cfp_array1d">cfp_array1d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, double<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.set">
void <code class="descname">cfp_array2d.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, double<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.set">
void <code class="descname">cfp_array3d.set</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;a</em>, uint<em>&nbsp;i</em>, uint<em>&nbsp;j</em>, uint<em>&nbsp;k</em>, double<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Array mutators for assigning values to array elements via multidimensional
indexing.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array1f.get_array">
void <code class="descname">cfp_array1f.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>*<em>&nbsp;self</em>, float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.get_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.get_array">
void <code class="descname">cfp_array1d.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array1d" title="cfp_array1d">cfp_array1d</a>*<em>&nbsp;self</em>, double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.get_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.get_array">
void <code class="descname">cfp_array2f.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;self</em>, float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.get_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.get_array">
void <code class="descname">cfp_array2d.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;self</em>, double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.get_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.get_array">
void <code class="descname">cfp_array3f.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em>, float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.get_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.get_array">
void <code class="descname">cfp_array3d.get_array</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em>, double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompress entire array; see <a class="reference internal" href="#_CPPv2NK3zfp5array3getEP6Scalar" title="zfp::array::get"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::get()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array1f.set_array">
void <code class="descname">cfp_array1f.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>*<em>&nbsp;self</em>, const float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.set_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.set_array">
void <code class="descname">cfp_array1d.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array1d" title="cfp_array1d">cfp_array1d</a>*<em>&nbsp;self</em>, const double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.set_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.set_array">
void <code class="descname">cfp_array2f.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;self</em>, const float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.set_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.set_array">
void <code class="descname">cfp_array2d.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;self</em>, const double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.set_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.set_array">
void <code class="descname">cfp_array3f.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em>, const float*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.set_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.set_array">
void <code class="descname">cfp_array3d.set_array</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em>, const double*<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.set_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize entire array; see <a class="reference internal" href="#_CPPv2N3zfp5array3setEPK6Scalar" title="zfp::array::set"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.size_x">
uint <code class="descname">cfp_array2f.size_x</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.size_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.size_y">
uint <code class="descname">cfp_array2f.size_y</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.size_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.size_x">
uint <code class="descname">cfp_array3f.size_x</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.size_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.size_y">
uint <code class="descname">cfp_array3f.size_y</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.size_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.size_z">
uint <code class="descname">cfp_array3f.size_z</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.size_z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.size_x">
uint <code class="descname">cfp_array2d.size_x</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.size_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.size_y">
uint <code class="descname">cfp_array2d.size_y</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.size_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.size_x">
uint <code class="descname">cfp_array3d.size_x</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.size_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.size_y">
uint <code class="descname">cfp_array3d.size_y</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.size_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.size_z">
uint <code class="descname">cfp_array3d.size_z</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.size_z" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#array-dims"><span class="std std-ref">Array dimensions</span></a>.</p>
</dd></dl>

<span class="target" id="cfp-resize"></span><dl class="function">
<dt id="c.cfp_array1f.resize">
void <code class="descname">cfp_array1f.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array1f" title="cfp_array1f">cfp_array1f</a>*<em>&nbsp;self</em>, uint<em>&nbsp;n</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1f.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2f.resize">
void <code class="descname">cfp_array2f.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array2f" title="cfp_array2f">cfp_array2f</a>*<em>&nbsp;self</em>, uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2f.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3f.resize">
void <code class="descname">cfp_array3f.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array3f" title="cfp_array3f">cfp_array3f</a>*<em>&nbsp;self</em>, uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, uint<em>&nbsp;nz</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3f.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array1d.resize">
void <code class="descname">cfp_array1d.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array1d" title="cfp_array1d">cfp_array1d</a>*<em>&nbsp;self</em>, uint<em>&nbsp;n</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array1d.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array2d.resize">
void <code class="descname">cfp_array2d.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array2d" title="cfp_array2d">cfp_array2d</a>*<em>&nbsp;self</em>, uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array2d.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.cfp_array3d.resize">
void <code class="descname">cfp_array3d.resize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.cfp_array3d" title="cfp_array3d">cfp_array3d</a>*<em>&nbsp;self</em>, uint<em>&nbsp;nx</em>, uint<em>&nbsp;ny</em>, uint<em>&nbsp;nz</em>, int<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array3d.resize" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#array-resize"><span class="std std-ref">Resize array</span></a>.</p>
</dd></dl>

<p>The six array types share many functions that have the same signature.
Below, each instance of <code class="code docutils literal"><span class="pre">cfp_array</span></code> generically refers to one of
those six types.</p>
<dl class="function">
<dt id="c.cfp_array.ctor_default">
cfp_array* <code class="descname">cfp_array.ctor_default</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.ctor_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor.  Allocate an empty array that later can be
<a class="reference internal" href="#cfp-resize"><span class="std std-ref">resized</span></a> and whose rate and cache size can be
set by <a class="reference internal" href="#c.cfp_array.set_rate" title="cfp_array.set_rate"><code class="xref c c-func docutils literal"><span class="pre">cfp_array.set_rate()</span></code></a> and <a class="reference internal" href="#c.cfp_array.set_cache_size" title="cfp_array.set_cache_size"><code class="xref c c-func docutils literal"><span class="pre">cfp_array.set_cache_size()</span></code></a>.
Return a pointer to the constructed array.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.ctor_copy">
cfp_array* <code class="descname">cfp_array.ctor_copy</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.ctor_copy" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#array-ctor-default"><span class="std std-ref">Copy constructor</span></a>.  Return a pointer to
the constructed array.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.dtor">
void <code class="descname">cfp_array.dtor</code><span class="sig-paren">(</span>cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.dtor" title="Permalink to this definition">¶</a></dt>
<dd><p>Destructor.  The destructor not only deallocates any compressed data
owned by the array, but also frees memory for itself, invalidating
the <em>self</em> pointer upon return.  Note that the user must explicitly
call the destructor to avoid memory leaks.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.deep_copy">
void <code class="descname">cfp_array.deep_copy</code><span class="sig-paren">(</span>cfp_array*<em>&nbsp;self</em>, const cfp_array*<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a deep copy of <em>src</em> analogous to the
<a class="reference internal" href="#array-copy"><span class="std std-ref">C++ assignment operator</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.rate">
double <code class="descname">cfp_array.rate</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.rate" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array4rateEv" title="zfp::array::rate"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::rate()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.set_rate">
double <code class="descname">cfp_array.set_rate</code><span class="sig-paren">(</span>cfp_array*<em>&nbsp;self</em>, double<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2N3zfp5array8set_rateEd" title="zfp::array::set_rate"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_rate()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.cache_size">
size_t <code class="descname">cfp_array.cache_size</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.cache_size" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array10cache_sizeEv" title="zfp::array::cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::cache_size()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.set_cache_size">
void <code class="descname">cfp_array.set_cache_size</code><span class="sig-paren">(</span>cfp_array*<em>&nbsp;self</em>, size_t<em>&nbsp;csize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.set_cache_size" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2N3zfp5array14set_cache_sizeE6size_t" title="zfp::array::set_cache_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::set_cache_size()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.clear_cache">
void <code class="descname">cfp_array.clear_cache</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array11clear_cacheEv" title="zfp::array::clear_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::clear_cache()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.flush_cache">
void <code class="descname">cfp_array.flush_cache</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.flush_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array11flush_cacheEv" title="zfp::array::flush_cache"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::flush_cache()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.compressed_size">
size_t <code class="descname">cfp_array.compressed_size</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.compressed_size" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_sizeEv" title="zfp::array::compressed_size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::compressed_size()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.compressed_data">
uchar* <code class="descname">cfp_array.compressed_data</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.compressed_data" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array15compressed_dataEv" title="zfp::array::compressed_data"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::compressed_data()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.size">
size_t <code class="descname">cfp_array.size</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#_CPPv2NK3zfp5array4sizeEv" title="zfp::array::size"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::size()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.get_flat">
float <code class="descname">cfp_array.get_flat</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;a</em>, uint<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.get_flat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
double <code class="descname">cfp_array.get_flat</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;a</em>, uint<em>&nbsp;index</em><span class="sig-paren">)</span></dt>
<dd><p>Flat index array accessors; see <a class="reference internal" href="#_CPPv2NK3zfp5arrayixE4uint" title="zfp::array::operator[]"><code class="xref cpp cpp-func docutils literal"><span class="pre">array::operator[]()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.cfp_array.set_flat">
void <code class="descname">cfp_array.set_flat</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;a</em>, uint<em>&nbsp;index</em>, float<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfp_array.set_flat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
void <code class="descname">cfp_array.set_flat</code><span class="sig-paren">(</span>const cfp_array*<em>&nbsp;a</em>, uint<em>&nbsp;index</em>, double<em>&nbsp;val</em><span class="sig-paren">)</span></dt>
<dd><p>Flat index array mutators; set array element with flat <em>index</em> to <em>val</em>.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Compressed Arrays</a><ul>
<li><a class="reference internal" href="#array-classes">Array Classes</a><ul>
<li><a class="reference internal" href="#base-class">Base Class</a></li>
<li><a class="reference internal" href="#common-methods">Common Methods</a></li>
<li><a class="reference internal" href="#d-2d-and-3d-arrays">1D, 2D, and 3D Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caching">Caching</a></li>
<li><a class="reference internal" href="#serialization">Serialization</a><ul>
<li><a class="reference internal" href="#header">Header</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#pointers">Pointers</a></li>
<li><a class="reference internal" href="#iterators">Iterators</a><ul>
<li><a class="reference internal" href="#all-iterators">All Iterators</a></li>
<li><a class="reference internal" href="#d-array-iterators">1D Array Iterators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#views">Views</a><ul>
<li><a class="reference internal" href="#immutable-view">Immutable view</a></li>
<li><a class="reference internal" href="#mutable-view">Mutable view</a></li>
<li><a class="reference internal" href="#flat-view">Flat view</a></li>
<li><a class="reference internal" href="#nested-view">Nested view</a></li>
<li><a class="reference internal" href="#slicing">Slicing</a></li>
<li><a class="reference internal" href="#private-immutable-view">Private immutable view</a></li>
<li><a class="reference internal" href="#private-mutable-view">Private mutable view</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c-bindings">C bindings</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="bit-stream.html"
                        title="previous chapter">Bit Stream API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="python.html"
                        title="next chapter">Python Bindings</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="python.html" title="Python Bindings"
             >next</a> |</li>
        <li class="right" >
          <a href="bit-stream.html" title="Bit Stream API"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">zfp 0.5.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2019, LLNL-CODE-663824.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>